<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon-16.png">
<link rel="icon" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png">
<link rel="mask-icon" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/safari-pinned-tab.svg" color="#2563eb">
<link rel="manifest" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/manifest.webmanifest" crossorigin="anonymous">
<title>Bunch Bets V6.0 Final - Nassau + Vegas</title>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<style>
:root { --bg:#0b0e13; --card:#0f1420; --txt:#ecf0f6; --muted:#a3a9b6; --border:#1e2633; --acc:#3b82f6; --success:#16a34a; --danger:#dc2626; --warning:#d97706; color-scheme: light dark; }
* { box-sizing:border-box; }
body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:var(--txt); background:var(--bg); }
header { background:var(--card); border-bottom:1px solid var(--border); padding:10px 12px; position:sticky; top:0; z-index:10; }
h1 { font-size:18px; margin:0; }
main { padding:12px; }
.row { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-start; }
.card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:12px; }
.btn { background:var(--card); border:1px solid var(--border); border-radius:999px; padding:8px 12px; cursor:pointer; color:var(--txt); transition:all 0.2s; }
.btn:hover:not(:disabled) { transform:translateY(-1px); }
.btn:disabled { opacity:0.5; cursor:not-allowed; }
.btn.primary { background:var(--acc); color:#fff; border-color:var(--acc); }
.btn.danger { background:var(--danger); color:#fff; border-color:var(--danger); }
.btn.share { background:var(--success); color:#fff; font-weight:600; }
.btn.small { padding:6px 10px; font-size:14px; }
.pill { border:1px solid var(--border); padding:6px 10px; border-radius:999px; display:inline-block; background:rgba(255,255,255,0.02); }
.grid { display:grid; gap:8px; }
.grid-2 { grid-template-columns:repeat(2,minmax(0,1fr)); }
.grid-3 { grid-template-columns:repeat(3,minmax(0,1fr)); }
.muted { color:var(--muted); }
.nowrap { white-space:nowrap; }
input[type="text"], input[type="tel"], input[type="number"], select { border:1px solid var(--border); border-radius:10px; padding:10px 12px; width:100%; font-size:16px; min-height:44px; color:var(--txt); background:rgba(255,255,255,0.06); }
input:focus, select:focus { outline:2px solid var(--acc); outline-offset:1px; }
::placeholder { color:var(--muted); opacity:0.9; }
table { border-collapse:collapse; width:100%; font-size:14px; }
th, td { border:1px solid var(--border); padding:6px; text-align:center; vertical-align:middle; }
th.sticky, td.sticky { position:sticky; left:0; background:var(--card); z-index:10; text-align:left; transform:translateZ(0); backface-visibility:hidden; }
.tabs { display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 10px; }
.tabs .btn.active { background:var(--acc); color:#fff; border-color:var(--acc); }
.scroll { overflow:auto; isolation:isolate; }
.note { font-size:12px; color:var(--muted); }
.error { position:fixed; bottom:8px; left:8px; right:8px; background:#fee2e2; color:#991b1b; border:1px solid #fecaca; border-radius:12px; padding:8px 12px; font-size:12px; display:none; z-index:9999; white-space:pre-wrap; }
.success-toast { position:fixed; top:70px; right:8px; background:var(--success); color:#fff; border-radius:12px; padding:12px 16px; z-index:9999; animation:slideIn 0.3s; box-shadow:0 4px 12px rgba(0,0,0,0.3); }
@keyframes slideIn { from { transform:translateX(400px); opacity:0; } to { transform:translateX(0); opacity:1; } }
.theme-g1 .card { outline:1px solid rgba(22,163,74,.45); background:linear-gradient(0deg,rgba(22,163,74,.08),rgba(22,163,74,.08)) var(--card); }
.theme-g2 .card { outline:1px solid rgba(220,38,38,.45); background:linear-gradient(0deg,rgba(220,38,38,.08),rgba(220,38,38,.08)) var(--card); }
.theme-g3 .card { outline:1px solid rgba(217,119,6,.45); background:linear-gradient(0deg,rgba(217,119,6,.08),rgba(217,119,6,.08)) var(--card); }
.theme-g4 .card { outline:1px solid rgba(99,102,241,.45); background:linear-gradient(0deg,rgba(99,102,241,.08),rgba(99,102,241,.08)) var(--card); }
.theme-g5 .card { outline:1px solid rgba(20,184,166,.45); background:linear-gradient(0deg,rgba(20,184,166,.08),rgba(20,184,166,.08)) var(--card); }
.theme-g6 .card { outline:1px solid rgba(219,39,119,.45); background:linear-gradient(0deg,rgba(219,39,119,.08),rgba(219,39,119,.08)) var(--card); }
.cellWrap { position:relative; }
.cellWrap input { width:54px; text-align:center; padding-right:14px; }
.cellWrap .dots { position:absolute; right:2px; top:4px; display:flex; flex-direction:column; gap:2px; pointer-events:none; z-index:1; }
.cellWrap .dot { width:6px; height:6px; border-radius:50%; }
.cellWrap .dot.g1 { background-color:#16a34a; }
.cellWrap .dot.g2 { background-color:#dc2626; }
.cellWrap .dot.g3 { background-color:#d97706; }
.cellWrap .dot.g4 { background-color:#6366f1; }
.cellWrap .dot.g5 { background-color:#14b8a6; }
.cellWrap .dot.g6 { background-color:#db2777; }
/* Score indicators - circles for under par, squares for over par */
.cellWrap .score-indicator { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
.cellWrap .score-indicator::before { content:''; position:absolute; width:28px; height:28px; border:2px solid transparent; }
.cellWrap .score-indicator::after { content:''; position:absolute; width:36px; height:36px; border:2px solid transparent; }
.cellWrap.birdie .score-indicator::before { border-color:#16a34a; border-radius:50%; }
.cellWrap.eagle .score-indicator::before { border-color:#16a34a; border-radius:50%; }
.cellWrap.eagle .score-indicator::after { border-color:#16a34a; border-radius:50%; }
.cellWrap.bogey .score-indicator::before { border-color:#dc2626; border-radius:4px; }
.cellWrap.double-bogey .score-indicator::before { border-color:#dc2626; border-radius:4px; }
.cellWrap.double-bogey .score-indicator::after { border-color:#dc2626; border-radius:4px; }
.junkWrap { position:relative; display:inline-block; }
.junkBox { width:48px; height:36px; text-align:center; font-size:20px; padding:6px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.22); position:relative; z-index:2; border-radius:6px; }
.junkVal { position:absolute; top:8px; right:6px; font-size:12px; pointer-events:none; z-index:1; }
.junkWrap .junkBox:not(:placeholder-shown) + .junkVal { display:none; }
.junkWrap:focus-within .junkVal { display:none; }
.game-options-row { display:grid; grid-template-columns:minmax(0,1.2fr) minmax(0,0.8fr); gap:16px 20px; align-items:start; }
@media (max-width: 360px) { .game-options-row { grid-template-columns:1fr; } }
@media (prefers-color-scheme: light) {
  :root { --bg:#f6f7fb; --card:#fff; --txt:#111; --muted:#666; --border:#e5e7eb; --acc:#2563eb; }
  .theme-g1 .card { outline:1px solid rgba(22,163,74,.35); background:linear-gradient(0deg,rgba(22,163,74,.10),rgba(22,163,74,.10)) var(--card); }
  .theme-g2 .card { outline:1px solid rgba(220,38,38,.35); background:linear-gradient(0deg,rgba(220,38,38,.10),rgba(220,38,38,.10)) var(--card); }
  .theme-g3 .card { outline:1px solid rgba(217,119,6,.35); background:linear-gradient(0deg,rgba(217,119,6,.10),rgba(217,119,6,.10)) var(--card); }
  .theme-g4 .card { outline:1px solid rgba(99,102,241,.35); background:linear-gradient(0deg,rgba(99,102,241,.10),rgba(99,102,241,.10)) var(--card); }
  .theme-g5 .card { outline:1px solid rgba(20,184,166,.35); background:linear-gradient(0deg,rgba(20,184,166,.10),rgba(20,184,166,.10)) var(--card); }
  .theme-g6 .card { outline:1px solid rgba(219,39,119,.35); background:linear-gradient(0deg,rgba(219,39,119,.10),rgba(219,39,119,.10)) var(--card); }
  input, .junkBox { background:#f3f4f6; border-color:#d1d5db; }
  .press-row { background:rgba(0,0,0,0.02); }
}
.ios .junkWrap .junkBox { color:transparent; -webkit-text-fill-color:transparent; caret-color:var(--txt); z-index:1; }
.ios .junkWrap .junkVal { position:absolute; inset:0; display:flex !important; align-items:center; justify-content:center; z-index:2; color:var(--txt); -webkit-text-fill-color:var(--txt); transform:translateZ(0); }
select.press-select { min-height:36px; padding:6px 8px; font-size:14px; }
.press-row { background:rgba(255,255,255,0.02); }
.press-row.theme-g1 { background:rgba(22,163,74,0.15); }
.press-row.theme-g2 { background:rgba(220,38,38,0.15); }
.press-row.theme-g3 { background:rgba(217,119,6,0.15); }
.press-row.theme-g4 { background:rgba(99,102,241,0.15); }
.press-row.theme-g5 { background:rgba(20,184,166,0.15); }
.press-row.theme-g6 { background:rgba(219,39,119,0.15); }
/* Scores/Junk Toggle Bar */
.scoring-toggle { display:flex; background:var(--card); border:1px solid var(--border); border-radius:10px; overflow:hidden; margin-bottom:12px; }
.scoring-toggle-btn { flex:1; padding:10px 16px; text-align:center; font-size:14px; font-weight:500; cursor:pointer; transition:all 0.2s; border:none; background:transparent; color:var(--muted); }
.scoring-toggle-btn.active { background:var(--acc); color:#fff; }
.scoring-toggle-btn:not(.active):hover { background:rgba(255,255,255,0.05); }
.press-label { font-weight:600; font-size:12px; }
.digits-display { font-size:20px; font-weight:700; font-family:monospace; color:var(--acc); }
.points-positive { color:var(--success); font-weight:600; }
.points-negative { color:var(--danger); font-weight:600; }
/* Live Sharing Styles */
.live-banner { background:linear-gradient(135deg,var(--acc),#6366f1); color:#fff; padding:8px 12px; text-align:center; font-weight:600; font-size:14px; }
.live-banner.viewer { background:linear-gradient(135deg,#d97706,#dc2626); }
.share-code { font-family:monospace; font-size:24px; font-weight:700; letter-spacing:2px; background:rgba(255,255,255,0.1); padding:8px 16px; border-radius:8px; display:inline-block; }
.modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1000; display:flex; align-items:center; justify-content:center; padding:16px; }
.modal { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:20px; max-width:400px; width:100%; max-height:90vh; overflow-y:auto; }
.modal h2 { margin:0 0 16px 0; font-size:18px; }
.modal-actions { display:flex; gap:8px; margin-top:16px; justify-content:flex-end; }
.copy-btn { background:var(--acc); color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:600; }
.copy-btn:hover { opacity:0.9; }
.join-input { font-family:monospace; font-size:20px; letter-spacing:2px; text-transform:uppercase; text-align:center; }
.sync-indicator { display:inline-block; width:8px; height:8px; border-radius:50%; background:#16a34a; margin-right:6px; animation:pulse 2s infinite; }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
/* Viewer mode - disable all inputs */
.viewer-mode input, .viewer-mode select, .viewer-mode button:not(.btn) { pointer-events:none; opacity:0.7; }
.viewer-mode .tabs .btn { pointer-events:auto; opacity:1; }
.viewer-mode #joinBtn { display:none; }

/* Hamburger Menu Styles */
.header-brand { display:flex; align-items:center; gap:10px; }
.header-brand img { width:36px; height:36px; border-radius:8px; }
.header-brand h1 { font-size:18px; margin:0; }
.hamburger { background:none; border:none; color:var(--txt); font-size:28px; cursor:pointer; padding:4px 8px; line-height:1; }
.hamburger:hover { color:var(--acc); }
.menu-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:100; opacity:0; visibility:hidden; transition:opacity 0.3s, visibility 0.3s; }
.menu-overlay.open { opacity:1; visibility:visible; }
.slide-menu { position:fixed; top:0; right:-280px; width:280px; height:100%; background:var(--card); border-left:1px solid var(--border); z-index:101; transition:right 0.3s ease; overflow-y:auto; display:flex; flex-direction:column; }
.slide-menu.open { right:0; }
.menu-header { padding:16px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between; }
.menu-header h2 { margin:0; font-size:16px; }
.menu-close { background:none; border:none; color:var(--txt); font-size:24px; cursor:pointer; padding:4px; line-height:1; }
.menu-close:hover { color:var(--danger); }
.menu-section { padding:12px 0; border-bottom:1px solid var(--border); }
.menu-section:last-child { border-bottom:none; }
.menu-section-title { padding:8px 16px; font-size:11px; text-transform:uppercase; color:var(--muted); letter-spacing:0.5px; }
.menu-item { display:block; width:100%; padding:12px 16px; background:none; border:none; color:var(--txt); font-size:15px; text-align:left; cursor:pointer; transition:background 0.2s; }
.menu-item:hover { background:rgba(255,255,255,0.05); }
.menu-item.active { color:var(--acc); background:rgba(59,130,246,0.1); }
.menu-item.danger { color:var(--danger); }
.menu-item.primary { color:var(--acc); font-weight:600; }

/* Wizard Styles */
.wizard-overlay { position:fixed; inset:0; z-index:200; display:flex; flex-direction:column; }
.wizard-splash {
  background: linear-gradient(135deg, #16a34a 0%, #15803d 50%, #166534 100%);
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
.wizard-splash img { width:45%; max-width:280px; height:auto; border-radius:24px; box-shadow:0 8px 32px rgba(0,0,0,0.3); opacity:0; animation: wizardFadeIn 1.5s ease-out forwards; }
@keyframes wizardFadeIn { from { opacity:0; } to { opacity:1; } }
.wizard-screen { background:var(--bg); flex:1; display:flex; flex-direction:column; overflow:hidden; }
.wizard-header { padding:20px 16px 12px; text-align:center; }
.wizard-header h2 { margin:0 0 4px 0; font-size:22px; }
.wizard-header p { margin:0; color:var(--muted); font-size:14px; }
.wizard-content { flex:1; overflow-y:auto; padding:12px 16px; }
.wizard-footer { padding:12px 16px; border-top:1px solid var(--border); background:var(--card); display:flex; flex-wrap:wrap; gap:8px; }
.wizard-footer .btn { flex:1; min-width:120px; padding:10px 12px; font-size:14px; }
.wizard-footer .btn.secondary { flex:0 0 auto; min-width:80px; background:var(--card); }
.wizard-skip { width:100%; text-align:center; margin-top:4px; }
.wizard-skip a { color:var(--muted); font-size:13px; text-decoration:underline; cursor:pointer; }
.wizard-skip a:hover { color:var(--acc); }
.wizard-player-row { display:grid; grid-template-columns:1fr 80px 40px; gap:8px; align-items:center; margin-bottom:12px; }
.wizard-player-row.header { font-size:12px; color:var(--muted); margin-bottom:8px; }
.wizard-player-row input { min-height:44px; }
.wizard-player-row .delete-btn { background:none; border:none; color:var(--danger); font-size:20px; cursor:pointer; padding:8px; }
.wizard-player-row .delete-btn:hover { opacity:0.7; }
.wizard-add-btn { background:rgba(59,130,246,0.1); border:1px dashed var(--acc); color:var(--acc); padding:12px; border-radius:10px; width:100%; cursor:pointer; font-size:14px; margin-top:8px; }
.wizard-add-btn:hover { background:rgba(59,130,246,0.2); }
.wizard-course-card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; margin-bottom:10px; cursor:pointer; transition:all 0.2s; }
.wizard-course-card:hover { border-color:var(--acc); }
.wizard-course-card.selected { border-color:var(--acc); background:rgba(59,130,246,0.1); }
.wizard-course-card h3 { margin:0 0 4px 0; font-size:15px; }
.wizard-course-card p { margin:0; font-size:12px; color:var(--muted); }
.wizard-section { margin-bottom:20px; }
.wizard-section-title { font-size:13px; color:var(--muted); margin-bottom:8px; text-transform:uppercase; letter-spacing:0.5px; }
.wizard-option { display:flex; align-items:center; gap:10px; padding:12px; background:var(--card); border:1px solid var(--border); border-radius:10px; margin-bottom:8px; cursor:pointer; }
.wizard-option:hover { border-color:var(--acc); }
.wizard-option.selected { border-color:var(--acc); background:rgba(59,130,246,0.1); }
.wizard-option input[type="radio"] { width:18px; height:18px; }
.wizard-team-zone { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; min-height:100px; text-align:center; }
.wizard-team-zone h4 { margin:0 0 8px 0; font-size:13px; color:var(--muted); text-align:center; }
.wizard-player-chip { display:inline-block; background:rgba(59,130,246,0.2); border:1px solid var(--acc); border-radius:20px; padding:6px 12px; margin:4px; font-size:13px; cursor:pointer; }
.wizard-player-chip:hover { background:rgba(59,130,246,0.3); }
.wizard-player-chip.team-a { background:rgba(22,163,74,0.2); border-color:#16a34a; }
.wizard-player-chip.team-b { background:rgba(220,38,38,0.2); border-color:#dc2626; }
.wizard-game-tabs { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
.wizard-game-tab { padding:6px 14px; border-radius:20px; font-size:13px; cursor:pointer; border:1px solid var(--border); background:var(--card); transition:all 0.2s; }
.wizard-game-tab:hover { border-color:var(--acc); }
.wizard-game-tab.active { background:var(--acc); color:#fff; border-color:var(--acc); }
.wizard-game-tab .delete-game { margin-left:6px; opacity:0.7; }
.wizard-game-tab .delete-game:hover { opacity:1; }
.wizard-holes-grid { display:grid; grid-template-columns:repeat(9, 1fr); gap:4px; margin-bottom:12px; }
.wizard-hole-col { display:flex; flex-direction:column; align-items:center; gap:2px; }
.wizard-hole-num { font-size:11px; font-weight:600; color:var(--muted); }
.wizard-hole-input { width:100%; min-width:0; padding:6px 2px; text-align:center; font-size:13px; border:1px solid var(--border); border-radius:6px; background:var(--card); }
.wizard-hole-input:focus { border-color:var(--acc); outline:none; }
/* Currency input styling for stakes/points */
.currency-input-wrap { position:relative; display:flex; align-items:center; }
.currency-input-wrap::before { content:'$'; position:absolute; left:10px; color:var(--muted); font-size:14px; pointer-events:none; z-index:1; }
.currency-input { width:80px; padding:8px 8px 8px 22px; font-size:14px; min-height:40px; text-align:right; }
</style>
</head>
<body>
<header>
  <div class="row" style="align-items:center; justify-content:space-between;">
    <div class="header-brand">
      <img src="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png" alt="Bunch Bets">
      <h1>Bunch Bets</h1>
    </div>
    <button class="hamburger" id="menuToggle" aria-label="Menu">&#9776;</button>
  </div>
</header>

<!-- Slide-out Menu -->
<div class="menu-overlay" id="menuOverlay"></div>
<div class="slide-menu" id="slideMenu">
  <div class="menu-header">
    <h2>Menu</h2>
    <button class="menu-close" id="menuClose">&times;</button>
  </div>
  <div class="menu-section">
    <button class="menu-item primary" id="startWizardBtn" style="background:var(--success);color:#fff;font-weight:600;text-align:center;border-radius:8px;margin:0 12px;">Start New Game</button>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Navigate</div>
    <div id="menuNav"></div>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Live Sharing</div>
    <button class="menu-item primary" id="hostBtn">Host Live Game</button>
    <button class="menu-item" id="joinBtn">Join Game</button>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Actions</div>
    <button class="menu-item" id="resetBtn">New Round</button>
    <button class="menu-item" id="clearBtn">Clear Scores</button>
    <button class="menu-item danger" id="factoryBtn">Factory Reset</button>
  </div>
</div>
<div id="liveBanner" class="live-banner" style="display:none;"></div>
<main>
  <div id="tabs"></div>
  <div id="app"></div>
</main>
<div id="err" class="error"></div>

<script>

(function(){
'use strict';

// === CONSTANTS ===
const STORAGE_KEY = 'nassauV28_complete';
const MIN_SCORE = 1, MAX_SCORE = 15, HOLES = 18;

// === FIREBASE CONFIG ===
// Live sharing enabled! Project: bunchbets.firebaseapp.com
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyDZlbkZMkfmFk1CS1i51JQ1NuknlNae0zo",
  authDomain: "bunchbets.firebaseapp.com",
  databaseURL: "https://bunchbets-default-rtdb.firebaseio.com",
  projectId: "bunchbets",
  storageBucket: "bunchbets.firebasestorage.app",
  messagingSenderId: "267555779116",
  appId: "1:267555779116:web:af1e05bacb82f0d4fe5789"
};

// === LIVE SYNC MODULE ===
window.LiveSync = {
  db: null,
  gameRef: null,
  shareCode: null,
  isHost: false,
  isViewer: false,
  unsubscribe: null,

  init() {
    if (FIREBASE_CONFIG.apiKey === "YOUR_API_KEY") {
      console.log('Firebase not configured - live sharing disabled');
      return false;
    }
    try {
      firebase.initializeApp(FIREBASE_CONFIG);
      this.db = firebase.database();
      return true;
    } catch (e) {
      console.error('Firebase init failed:', e);
      return false;
    }
  },

  generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
  },

  async hostGame() {
    if (!this.init()) {
      Err.show('Firebase not configured. See instructions in index.html to enable live sharing.');
      return null;
    }

    this.shareCode = this.generateCode();
    this.isHost = true;
    this.isViewer = false;
    this.gameRef = this.db.ref('games/' + this.shareCode);

    try {
      await this.gameRef.set({
        data: State.data,
        presets: State.presets,
        updatedAt: firebase.database.ServerValue.TIMESTAMP
      });

      this.showBanner(`Hosting: ${this.shareCode}`, false);
      Err.toast('Game hosted! Share code: ' + this.shareCode);
      return this.shareCode;
    } catch (e) {
      Err.show('Failed to host game: ' + e.message);
      this.isHost = false;
      return null;
    }
  },

  async joinGame(code) {
    if (!this.init()) {
      Err.show('Firebase not configured. See instructions in index.html to enable live sharing.');
      return false;
    }

    code = code.toUpperCase().trim();
    if (!/^[A-Z0-9]{6}$/.test(code)) {
      Err.show('Invalid code. Should be 6 characters.');
      return false;
    }

    this.gameRef = this.db.ref('games/' + code);

    try {
      const snapshot = await this.gameRef.once('value');
      if (!snapshot.exists()) {
        Err.show('Game not found. Check the code and try again.');
        return false;
      }

      this.shareCode = code;
      this.isViewer = true;
      this.isHost = false;

      // Subscribe to updates
      this.unsubscribe = this.gameRef.on('value', (snap) => {
        const val = snap.val();
        if (val && val.data) {
          State.data = val.data;
          State.presets = val.presets || [];
          // Sanitize games to ensure all player entries exist
          if (State.data.games && Array.isArray(State.data.games)) {
            State.data.games = State.data.games.map(g => Game.sanitize(g));
          }
          State.scheduleRender();
        }
      });

      this.showBanner(`Viewing: ${code} (read-only)`, true);
      this.disableEditing();
      Err.toast('Connected to game ' + code);
      return true;
    } catch (e) {
      Err.show('Failed to join game: ' + e.message);
      return false;
    }
  },

  syncToFirebase() {
    if (!this.isHost || !this.gameRef) return;

    this.gameRef.update({
      data: State.data,
      presets: State.presets,
      updatedAt: firebase.database.ServerValue.TIMESTAMP
    }).catch(e => console.error('Sync failed:', e));
  },

  stopSharing() {
    if (this.unsubscribe && this.gameRef) {
      this.gameRef.off('value', this.unsubscribe);
    }
    this.shareCode = null;
    this.isHost = false;
    this.isViewer = false;
    this.gameRef = null;
    this.hideBanner();
    this.enableEditing();
    Err.toast('Disconnected from live game');
  },

  showBanner(text, isViewer) {
    const banner = document.getElementById('liveBanner');
    banner.innerHTML = `<span class="sync-indicator"></span>${text} <button class="btn small" style="margin-left:12px;padding:4px 8px;" onclick="LiveSync.stopSharing()">Disconnect</button>`;
    banner.className = 'live-banner' + (isViewer ? ' viewer' : '');
    banner.style.display = 'block';
  },

  hideBanner() {
    document.getElementById('liveBanner').style.display = 'none';
  },

  disableEditing() {
    document.body.classList.add('viewer-mode');
    // Hide edit buttons
    ['resetBtn', 'clearBtn', 'factoryBtn', 'hostBtn'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  },

  enableEditing() {
    document.body.classList.remove('viewer-mode');
    ['resetBtn', 'clearBtn', 'factoryBtn', 'hostBtn'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = '';
    });
  },

  showHostModal() {
    if (this.isHost) {
      // Already hosting - show current code
      this.showShareModal(this.shareCode);
      return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Host Live Game</h2>
        <p class="muted">Share your game in real-time. Others can view scores as you enter them.</p>
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
          <button class="btn primary" id="startHostBtn">Start Hosting</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    document.getElementById('startHostBtn').onclick = async () => {
      const code = await this.hostGame();
      overlay.remove();
      if (code) this.showShareModal(code);
    };

    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  showShareModal(code) {
    const url = window.location.origin + window.location.pathname + '?join=' + code;
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Share This Code</h2>
        <p class="muted" style="margin-bottom:16px;">Others can join with this code to view live scores:</p>
        <div style="text-align:center;margin:20px 0;">
          <div class="share-code">${code}</div>
        </div>
        <p class="muted" style="font-size:12px;">Or share this link:</p>
        <input type="text" value="${url}" readonly style="font-size:12px;margin-bottom:8px;" onclick="this.select()">
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button>
          <button class="copy-btn" onclick="navigator.clipboard.writeText('${code}');Err.toast('Code copied!');">Copy Code</button>
          <button class="copy-btn" onclick="navigator.clipboard.writeText('${url}');Err.toast('Link copied!');">Copy Link</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  showJoinModal() {
    if (this.isViewer) {
      Err.toast('Already viewing a game. Disconnect first.');
      return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Join Live Game</h2>
        <p class="muted">Enter the 6-character code to view a live game:</p>
        <input type="text" id="joinCodeInput" class="join-input" maxlength="6" placeholder="ABC123" style="margin:16px 0;">
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
          <button class="btn primary" id="joinGameBtn">Join</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    const input = document.getElementById('joinCodeInput');
    input.focus();
    input.oninput = () => { input.value = input.value.toUpperCase(); };
    input.onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('joinGameBtn').click(); };

    document.getElementById('joinGameBtn').onclick = async () => {
      const code = input.value;
      const success = await this.joinGame(code);
      if (success) overlay.remove();
    };

    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  }
};

// === UTILITIES ===
const Utils = {
  fmt: n => isFinite(n) ? (n<0?'-':'') + '$' + Math.abs(n).toFixed(2) : '$0.00',
  make18: fill => Array(HOLES).fill(fill),
  uid: () => Math.random().toString(36).slice(2) + Date.now().toString(36),
  sanitize: v => String(v).replace(/[^0-9]/g, ''),
  sumRange(arr, start, end) {
    let total = 0, has = false;
    for (let i = start; i <= end && i < arr.length; i++) {
      const v = arr[i];
      if (v != null && isFinite(+v)) { total += +v; has = true; }
    }
    return has ? total : null;
  },
  clone: obj => JSON.parse(JSON.stringify(obj))
};

// === ERROR HANDLER ===
window.Err = {
  box: document.getElementById('err'),
  show(msg) { 
    console.error(msg);
    this.box.textContent = msg; 
    this.box.style.display = 'block'; 
    setTimeout(() => this.box.style.display = 'none', 5000); 
  },
  toast(msg) { 
    const t = document.createElement('div'); 
    t.className = 'success-toast'; 
    t.textContent = msg; 
    document.body.appendChild(t); 
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 2000); 
  }
};

window.addEventListener('error', ev => Err.show(`Error: ${ev.message}`));

// === STATE MANAGER ===
const State = {
  data: {
    tab: 'setup',
    players: [{id:'p1',name:'P1'},{id:'p2',name:'P2'},{id:'p3',name:'P3'},{id:'p4',name:'P4'},{id:'p5',name:'P5'}],
    games: [],
    course: {
      name: 'El Macero',
      hcp: [7,15,9,1,11,3,17,13,5,4,2,10,8,12,14,18,6,16],
      par: [4,5,3,4,5,4,3,4,4,4,4,3,4,4,5,3,4,5]
    },
    settings: { thTop: 12, thMin: 5 },
    debugStatus: false,
    lastActiveDate: null,
    roundCompleteShown: false
  },
  presets: {
    'El Macero': { hcp:[7,15,9,1,11,3,17,13,5,4,2,10,8,12,14,18,6,16], par:[4,5,3,4,5,4,3,4,4,4,4,3,4,4,5,3,4,5] },
    'Del Paso': { hcp:[11,17,1,7,15,9,3,5,13,12,10,18,8,16,6,2,14,4], par:[5,3,4,5,3,4,4,4,4,4,4,3,5,3,5,4,3,4] }
  },
  locks: 0,
  saveTimer: null,
  renderTimer: null,

  begin() { this.locks++; },
  end() {
    this.locks = Math.max(0, this.locks - 1);
    if (!this.locks) {
      this.scheduleSave();
      this.scheduleRender();
      // Check if round just completed
      if (!this.data.roundCompleteShown && this.isRoundComplete()) {
        this.data.roundCompleteShown = true;
        this.scheduleSave();
        setTimeout(() => UI.showRoundCompleteModal(), 300);
      }
    }
  },

  isRoundComplete() {
    // Check if all players have scores for all 18 holes
    const g = this.data.games[0];
    if (!g) return false;
    for (const p of this.data.players) {
      const scores = g.gross[p.id];
      if (!scores) return false;
      for (let i = 0; i < 18; i++) {
        if (scores[i] === null || scores[i] === undefined) return false;
      }
    }
    return true;
  },
  
  scheduleSave() {
    clearTimeout(this.saveTimer);
    this.saveTimer = setTimeout(() => {
      try {
        // Update lastActiveDate to today
        this.data.lastActiveDate = new Date().toDateString();
        const saveData = {...this.data, presets: this.presets};
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
        // Sync to Firebase if hosting
        if (LiveSync.isHost) LiveSync.syncToFirebase();
      } catch(e) {
        Err.show('Save failed: ' + e.message);
      }
    }, 200);
  },

  scheduleRender() {
    if (this.locks > 0) return;
    clearTimeout(this.renderTimer);
    this.renderTimer = setTimeout(() => {
      try { UI.render(); }
      catch(e) { Err.show('Render failed: ' + e.message); }
    }, 120);
  },

  load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      if (obj.players && Array.isArray(obj.players)) this.data.players = obj.players;
      if (obj.games && Array.isArray(obj.games)) this.data.games = obj.games.map(Game.sanitize);
      if (obj.course) this.data.course = obj.course;
      if (obj.presets) this.presets = obj.presets;
      if (obj.settings) this.data.settings = obj.settings;
      if (obj.lastActiveDate) this.data.lastActiveDate = obj.lastActiveDate;
      this.data.roundCompleteShown = !!obj.roundCompleteShown;
      this.data.tab = obj.tab || 'setup';
      this.data.debugStatus = !!obj.debugStatus;
      return true;
    } catch(e) { 
      Err.show('Load failed: ' + e.message);
      return false; 
    }
  }
};

// === GAME LOGIC ===
const Game = {
  create(clone = false) {
    const g = {
      id: Utils.uid(),
      gameType: 'nassau',
      teamA: ['p1','p2'], 
      teamB: ['p3','p4'],
      teamSize: 2, 
      scoringMode: 'hi_low',
      stakes: {front:2, back:4, overall:2},
      autoPress: {front:true, back:true, overall:false},
      junkValue: {front:1, back:2},
      pointValue: {front:1, back:1},
      presses: Utils.make18(''),
      gross: {}, 
      junkCounts: {}, 
      strokesCount: {}
    };
    State.data.players.forEach(p => {
      g.junkCounts[p.id] = Utils.make18(0);
      g.strokesCount[p.id] = 0;
      g.gross[p.id] = clone && State.data.games[0] ? [...State.data.games[0].gross[p.id]] : Utils.make18(null);
    });
    return g;
  },

  sanitize(g) {
    if (!g) return this.create();
    g.id = g.id || Utils.uid();
    g.gameType = ['nassau','vegas'].includes(g.gameType) ? g.gameType : 'nassau';
    
    const maxTeamSize = g.gameType === 'vegas' ? 2 : (g.teamSize || 2);
    g.teamSize = [1,2].includes(g.teamSize) ? g.teamSize : 2;
    g.scoringMode = ['hi_low','low_net'].includes(g.scoringMode) ? g.scoringMode : 'hi_low';
    g.teamA = (g.teamA || []).slice(0, maxTeamSize);
    g.teamB = (g.teamB || []).slice(0, maxTeamSize);
    g.stakes = g.stakes || {front:2,back:4,overall:2};
    ['front','back','overall'].forEach(k => g.stakes[k] = Math.max(0, parseInt(g.stakes[k])||0));
    g.autoPress = g.autoPress || {front:true,back:true,overall:false};
    g.junkValue = g.junkValue || {front:1,back:2};
    ['front','back'].forEach(k => g.junkValue[k] = Math.max(0, parseInt(g.junkValue[k])||0));
    g.pointValue = g.pointValue || {front:1,back:1};
    ['front','back'].forEach(k => g.pointValue[k] = Math.max(0, parseFloat(g.pointValue[k])||1));
    
    let pa = Array.isArray(g.presses) ? g.presses.slice(0,18) : Utils.make18('');
    while (pa.length < 18) pa.push('');
    g.presses = pa.map(v => ['','press','blind'].includes(v) ? v : '');
    
    g.gross = g.gross || {};
    g.junkCounts = g.junkCounts || {};
    g.strokesCount = g.strokesCount || {};
    
    State.data.players.forEach(p => {
      let ga = Array.isArray(g.gross[p.id]) ? g.gross[p.id].slice(0,18) : Utils.make18(null);
      while (ga.length < 18) ga.push(null);
      ga = ga.map(v => {
        if (v === '' || v == null) return null;
        const n = parseInt(v);
        return (n >= MIN_SCORE && n <= MAX_SCORE) ? n : null;
      });
      g.gross[p.id] = ga;
      
      let ja = Array.isArray(g.junkCounts[p.id]) ? g.junkCounts[p.id].slice(0,18) : Utils.make18(0);
      while (ja.length < 18) ja.push(0);
      g.junkCounts[p.id] = ja.map(v => Math.max(0, parseInt(v)||0));
      
      g.strokesCount[p.id] = Math.max(0, parseInt(g.strokesCount[p.id])||0);
    });
    return g;
  },

  strokes(g, pid, hole) {
    const total = g.strokesCount[pid] || 0;
    if (!total) return 0;
    const base = Math.floor(total / 18);
    const rem = total % 18;
    const rank = State.data.course.hcp[hole] || 0;
    return base + (rank > 0 && rank <= rem ? 1 : 0);
  },

  net(gross, strokes) {
    return (gross != null && isFinite(gross)) ? gross - (strokes||0) : null;
  },

  holeDiff(g, hole) {
    const A = g.teamA || [], B = g.teamB || [];
    const bestNet = (team) => {
      let best = Infinity, has = false;
      team.forEach(pid => {
        const gr = g.gross[pid] && g.gross[pid][hole];
        const n = this.net(gr, this.strokes(g, pid, hole));
        if (n != null) { best = Math.min(best, n); has = true; }
      });
      return has ? best : null;
    };

    if (g.scoringMode === 'low_net' || A.length < 2 || B.length < 2) {
      const aL = bestNet(A), bL = bestNet(B);
      if (aL == null || bL == null) return null;
      return aL < bL ? 1 : (bL < aL ? -1 : 0);
    }

    const a0 = g.gross[A[0]] && g.gross[A[0]][hole];
    const a1 = g.gross[A[1]] && g.gross[A[1]][hole];
    const b0 = g.gross[B[0]] && g.gross[B[0]][hole];
    const b1 = g.gross[B[1]] && g.gross[B[1]][hole];
    if (a0 == null || a1 == null || b0 == null || b1 == null) return null;

    const aN0 = this.net(a0, this.strokes(g,A[0],hole));
    const aN1 = this.net(a1, this.strokes(g,A[1],hole));
    const bN0 = this.net(b0, this.strokes(g,B[0],hole));
    const bN1 = this.net(b1, this.strokes(g,B[1],hole));

    const aLow = Math.min(aN0,aN1), bLow = Math.min(bN0,bN1);
    const aHi = Math.max(aN0,aN1), bHi = Math.max(bN0,bN1);
    
    let d = 0;
    if (aLow < bLow) d++; else if (bLow < aLow) d--;
    if (aHi < bHi) d++; else if (bHi < aHi) d--;
    return d;
  },

  buildSegment(g, start, end, stake, autoPress) {
    const diffs = [];
    for (let i = 0; i < 18; i++) diffs.push(this.holeDiff(g, i));
    
    const lines = [{start, end, stake, pressesTriggered:0}];
    
    if (autoPress) {
      for (let h = start; h <= end; h++) {
        let pressed = false;
        lines.forEach(line => {
          if (line.start > h || h >= end) return;
          let cum = 0, ok = true;
          for (let i = line.start; i <= h; i++) {
            if (diffs[i] == null) { ok = false; break; }
            cum += diffs[i];
          }
          if (!ok) return;
          const k = Math.floor(Math.abs(cum) / 2);
          if (k > line.pressesTriggered && !pressed) {
            const next = h + 1;
            if (!lines.some(l => l.start === next)) {
              lines.push({start:next, end, stake, pressedBy:cum<0?'A':'B', pressesTriggered:0});
              pressed = true;
            }
            line.pressesTriggered = k;
          }
        });
      }
    }

    const winners = [];
    let payA = 0, teamPayA = 0;
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;

    lines.forEach(line => {
      let cum = 0, hasAnyScore = false;
      for (let i = line.start; i <= line.end; i++) {
        if (diffs[i] != null) {
          cum += diffs[i];
          hasAnyScore = true;
        }
      }
      
      if (!hasAnyScore) {
        winners.push('â€”');
        return;
      }
      
      // Show current standing even if incomplete (always from Team A perspective)
      if (cum > 0) { winners.push(`+${cum}`); payA += line.stake; teamPayA += line.stake * szB; }
      else if (cum < 0) { winners.push(`${cum}`); payA -= line.stake; teamPayA -= line.stake * szA; }
      else winners.push('E');
    });

    return {lines, winners, payA, teamPayA};
  },

  hasAnyScores(g) {
    return State.data.players.some(p => {
      const arr = g.gross[p.id] || [];
      return arr.some(score => score != null);
    });
  },

  computeJunk(g) {
    const sumTeam = (team, s, e) => {
      let tot = 0;
      team.forEach(pid => {
        const arr = g.junkCounts[pid] || [];
        for (let h = s; h <= e; h++) tot += (arr[h] || 0);
      });
      return tot;
    };
    const aF = sumTeam(g.teamA||[], 0, 8);
    const aB = sumTeam(g.teamA||[], 9, 17);
    const bF = sumTeam(g.teamB||[], 0, 8);
    const bB = sumTeam(g.teamB||[], 9, 17);
    const aVal = aF * (g.junkValue.front||0) + aB * (g.junkValue.back||0);
    const bVal = bF * (g.junkValue.front||0) + bB * (g.junkValue.back||0);
    return {aVal, bVal, netA: aVal - bVal};
  },

  computeResult(g) {
    const front = this.buildSegment(g, 0, 8, g.stakes.front, g.autoPress.front);
    const back = this.buildSegment(g, 9, 17, g.stakes.back, g.autoPress.back);
    const overall = this.buildSegment(g, 0, 17, g.stakes.overall, g.autoPress.overall);
    const junk = this.computeJunk(g);
    
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;
    let junkTeam = 0;
    if (junk.netA > 0) junkTeam = junk.netA * szB;
    else if (junk.netA < 0) junkTeam = junk.netA * szA;
    
    const total = front.teamPayA + back.teamPayA + overall.teamPayA + junkTeam;
    
    return {
      segments: {front, back, overall},
      junk,
      teamTotals: {
        front: front.teamPayA,
        back: back.teamPayA,
        overall: overall.teamPayA,
        junk: junkTeam,
        total
      }
    };
  },

  computeVegasHole(g, hole) {
    const par = State.data.course.par[hole] || 4;
    const maxNet = par + 3; // Triple bogey max for Vegas

    const getTeamScores = (team) => {
      if (team.length < 2) return null;
      const p1gross = g.gross[team[0]] && g.gross[team[0]][hole];
      const p2gross = g.gross[team[1]] && g.gross[team[1]][hole];
      if (p1gross == null || p2gross == null) return null;

      // Calculate net scores, capped at triple bogey
      const p1net = Math.min(this.net(p1gross, this.strokes(g, team[0], hole)), maxNet);
      const p2net = Math.min(this.net(p2gross, this.strokes(g, team[1], hole)), maxNet);

      return {
        p1gross, p2gross, p1net, p2net,
        scores: [p1net, p2net].sort((a,b) => a-b)
      };
    };
    
    const teamA = getTeamScores(g.teamA || []);
    const teamB = getTeamScores(g.teamB || []);
    
    if (!teamA || !teamB) return null;
    
    const hasBirdie = (team) => team.p1gross < par || team.p2gross < par;
    const hasNetParOrBetter = (team) => team.p1net <= par || team.p2net <= par;

    // Flip conditions:
    // - Opponent birdie (gross) always flips your number
    // - Your own bogey flips your number, BUT only if no one on your team has net par or better
    //   (net par or better "protects" your team from self-inflicted flip)
    const aFlip = hasBirdie(teamB) || !hasNetParOrBetter(teamA);
    const bFlip = hasBirdie(teamA) || !hasNetParOrBetter(teamB);
    
    const formNumber = (data, flip) => {
      const [low, high] = data.scores;
      return flip ? (high * 10 + low) : (low * 10 + high);
    };
    
    const numA = formNumber(teamA, aFlip);
    const numB = formNumber(teamB, bFlip);
    const diff = Math.abs(numA - numB);
    
    const basePoints = numA < numB ? diff : (numA > numB ? -diff : 0);
    
    const press = g.presses[hole] || '';
    let multiplier = 1;
    if (press === 'press') multiplier = 2;
    else if (press === 'blind') multiplier = 4;
    
    return {
      numA,
      numB,
      aFlip,
      bFlip,
      basePoints,
      multiplier,
      pointsToA: basePoints * multiplier
    };
  },

  computeVegasResult(g) {
    let frontPoints = 0, backPoints = 0;
    const holeDetails = [];
    
    for (let h = 0; h < 18; h++) {
      const result = this.computeVegasHole(g, h);
      holeDetails.push(result);
      
      if (result) {
        if (h <= 8) frontPoints += result.pointsToA;
        else backPoints += result.pointsToA;
      }
    }
    
    const frontValue = frontPoints * (g.pointValue.front || 0) * 2;
    const backValue = backPoints * (g.pointValue.back || 0) * 2;
    
    const junk = this.computeJunk(g);
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;
    let junkTeam = 0;
    if (junk.netA > 0) junkTeam = junk.netA * szB;
    else if (junk.netA < 0) junkTeam = junk.netA * szA;
    
    return {
      holeDetails,
      frontPoints,
      backPoints,
      frontValue,
      backValue,
      junkValue: junkTeam,
      totalValue: frontValue + backValue + junkTeam
    };
  },

  getLastScored() {
    const g = State.data.games[0];
    if (!g || !g.gross) return -1;
    let last = -1;
    for (let h = 0; h < 18; h++) {
      for (const p of State.data.players) {
        const v = g.gross[p.id] && g.gross[p.id][h];
        if (v != null && v !== '') { last = h; break; }
      }
    }
    return last;
  }
};

// === DOM HELPER ===
const h = (tag, attrs = {}, children = []) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v]) => {
    if (k === 'class') el.className = v;
    else if (k === 'style') el.setAttribute('style', v);
    else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2).toLowerCase(), v);
    else if (k === 'value') el.value = v ?? '';
    else if (k === 'checked') el.checked = !!v;
    else if (k === 'disabled') el.disabled = !!v;
    else if (k === 'selected') el.selected = !!v;
    else el.setAttribute(k, v);
  });
  (Array.isArray(children) ? children : [children]).forEach(ch => {
    if (ch == null) return;
    el.appendChild(typeof ch === 'string' ? document.createTextNode(ch) : ch);
  });
  return el;
};

// === WIZARD ===
const Wizard = {
  active: false,
  step: 'splash', // splash, course, players, game, done
  data: {
    players: [{name:'', handicap:0}, {name:'', handicap:0}],
    selectedCourse: null,
    games: []
  },
  currentGameIndex: 0,

  start() {
    this.active = true;
    this.step = 'splash';
    this.data = {
      players: [{name:'', handicap:0}, {name:'', handicap:0}],
      selectedCourse: null,
      games: []
    };
    this.currentGameIndex = 0;
    this.data.games.push(this.createGameData());
    this.render();
    // Auto-advance from splash after 4 seconds
    setTimeout(() => {
      if (this.step === 'splash') {
        this.step = 'course';
        this.render();
      }
    }, 4000);
  },

  getCurrentGame() {
    return this.data.games[this.currentGameIndex];
  },

  switchToGame(index) {
    if (index >= 0 && index < this.data.games.length) {
      this.currentGameIndex = index;
      this.render();
    }
  },

  addNewGame() {
    const lastGame = this.getCurrentGame();
    const newGame = this.createGameData();
    // Copy team assignments from last game
    newGame.teamA = [...lastGame.teamA];
    newGame.teamB = [...lastGame.teamB];
    this.data.games.push(newGame);
    this.currentGameIndex = this.data.games.length - 1;
    this.render();
  },

  deleteGame(index) {
    if (this.data.games.length <= 1) return;
    this.data.games.splice(index, 1);
    if (this.currentGameIndex >= this.data.games.length) {
      this.currentGameIndex = this.data.games.length - 1;
    }
    this.render();
  },

  createGameData() {
    return {
      gameType: 'nassau',
      teamA: [],
      teamB: [],
      withJunk: true,
      handicapMode: 'full', // full, off_low, team_delta
      stakes: {front:2, back:2, overall:2},
      junkValue: {front:1, back:1},
      pointValue: {front:1, back:1}
    };
  },

  skip() {
    this.active = false;
    this.removeOverlay();
    State.data.tab = 'setup';
    State.scheduleRender();
  },

  finish() {
    // Apply wizard data to State
    // Players
    State.data.players = this.data.players.filter(p => p.name.trim()).map((p, i) => ({
      id: 'p' + (i+1),
      name: p.name.trim()
    }));

    // Course (if new one was selected/created, it's already in State.data.course)

    // Games
    State.data.games = this.data.games.map((wg, idx) => {
      const g = Game.create();
      g.gameType = wg.gameType;
      g.teamA = wg.teamA;
      g.teamB = wg.teamB;
      g.stakes = {...wg.stakes};
      g.junkValue = wg.withJunk ? {...wg.junkValue} : {front:0, back:0};
      g.pointValue = {...wg.pointValue};

      // Apply handicap strokes based on mode
      const playerHandicaps = {};
      this.data.players.forEach((p, i) => {
        if (p.name.trim()) playerHandicaps['p'+(i+1)] = p.handicap || 0;
      });

      if (wg.handicapMode === 'full') {
        // Everyone gets full strokes
        Object.keys(playerHandicaps).forEach(pid => {
          g.strokesCount[pid] = playerHandicaps[pid];
        });
      } else if (wg.handicapMode === 'off_low') {
        // Reduce by lowest
        const min = Math.min(...Object.values(playerHandicaps));
        Object.keys(playerHandicaps).forEach(pid => {
          g.strokesCount[pid] = playerHandicaps[pid] - min;
        });
      } else if (wg.handicapMode === 'team_delta') {
        // High player on high team gets delta
        const teamATotal = wg.teamA.reduce((s, pid) => s + (playerHandicaps[pid]||0), 0);
        const teamBTotal = wg.teamB.reduce((s, pid) => s + (playerHandicaps[pid]||0), 0);
        Object.keys(playerHandicaps).forEach(pid => g.strokesCount[pid] = 0);

        if (teamATotal > teamBTotal) {
          // Team A is high, find high player on Team A
          let highPid = wg.teamA[0], highVal = playerHandicaps[wg.teamA[0]] || 0;
          wg.teamA.forEach(pid => {
            if ((playerHandicaps[pid]||0) > highVal) { highPid = pid; highVal = playerHandicaps[pid]||0; }
          });
          g.strokesCount[highPid] = teamATotal - teamBTotal;
        } else if (teamBTotal > teamATotal) {
          // Team B is high
          let highPid = wg.teamB[0], highVal = playerHandicaps[wg.teamB[0]] || 0;
          wg.teamB.forEach(pid => {
            if ((playerHandicaps[pid]||0) > highVal) { highPid = pid; highVal = playerHandicaps[pid]||0; }
          });
          g.strokesCount[highPid] = teamBTotal - teamATotal;
        }
      }

      return Game.sanitize(g);
    });

    this.active = false;
    this.removeOverlay();
    State.data.tab = 'scores';
    State.data.roundCompleteShown = false;
    State.scheduleSave();
    State.scheduleRender();
    Err.toast('Game ready! Enter scores.');
  },

  removeOverlay() {
    const overlay = document.getElementById('wizardOverlay');
    if (overlay) overlay.remove();
  },

  render() {
    this.removeOverlay();
    if (!this.active) return;

    const overlay = document.createElement('div');
    overlay.id = 'wizardOverlay';
    overlay.className = 'wizard-overlay';

    let content;
    switch(this.step) {
      case 'splash': content = this.renderSplash(); break;
      case 'course': content = this.renderCourse(); break;
      case 'courseSetup': content = this.renderCourseSetup(); break;
      case 'players': content = this.renderPlayers(); break;
      case 'game': content = this.renderGame(); break;
      default: content = document.createElement('div');
    }

    overlay.appendChild(content);
    document.body.appendChild(overlay);
  },

  renderSplash() {
    const div = document.createElement('div');
    div.className = 'wizard-splash';
    div.innerHTML = `<img src="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png" alt="Bunch Bets">`;
    return div;
  },

  renderCourse() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    const presetNames = Object.keys(State.presets || {});
    const coursesHtml = presetNames.map(name => `
      <div class="wizard-course-card" data-course="${name}">
        <h3>${name}</h3>
        <p>Saved course preset</p>
      </div>
    `).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Select Course</h2>
        <p>Choose a saved course or use current setup</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-course-card selected" data-course="__current__">
          <h3>Current Course</h3>
          <p>Use existing course configuration</p>
        </div>
        ${coursesHtml}
        <div class="wizard-course-card" data-course="__new__">
          <h3>+ Set Up New Course</h3>
          <p>Configure par and handicap for each hole</p>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn primary" id="wizardCourseNext">Next</button>
        <div class="wizard-skip">
          <a id="wizardSkip">Skip to Advanced Setup</a>
        </div>
      </div>
    `;

    // Event handlers
    setTimeout(() => {
      div.querySelectorAll('.wizard-course-card').forEach(card => {
        card.onclick = () => {
          div.querySelectorAll('.wizard-course-card').forEach(c => c.classList.remove('selected'));
          card.classList.add('selected');
          this.data.selectedCourse = card.dataset.course;
        };
      });

      document.getElementById('wizardCourseNext').onclick = () => {
        if (this.data.selectedCourse === '__new__') {
          // Go to course setup screen
          this.step = 'courseSetup';
          this.render();
          return;
        }
        if (this.data.selectedCourse && this.data.selectedCourse !== '__current__') {
          // Load preset
          const preset = State.presets[this.data.selectedCourse];
          if (preset) {
            State.data.course.par = [...preset.par];
            State.data.course.hcp = [...preset.hcp];
          }
        }
        this.step = 'players';
        this.render();
      };

      document.getElementById('wizardSkip').onclick = () => this.skip();
    }, 0);

    return div;
  },

  renderCourseSetup() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    // Initialize temp course data if not set
    if (!this.data.newCourse) {
      this.data.newCourse = {
        name: '',
        par: [...State.data.course.par],
        hcp: [...State.data.course.hcp]
      };
    }

    const frontHoles = [];
    const backHoles = [];
    for (let i = 0; i < 9; i++) {
      frontHoles.push(`
        <div class="wizard-hole-col">
          <div class="wizard-hole-num">${i+1}</div>
          <input type="number" class="wizard-hole-input" data-hole="${i}" data-field="par" value="${this.data.newCourse.par[i] || ''}" min="3" max="6" placeholder="P">
          <input type="number" class="wizard-hole-input" data-hole="${i}" data-field="hcp" value="${this.data.newCourse.hcp[i] || ''}" min="1" max="18" placeholder="H">
        </div>
      `);
      backHoles.push(`
        <div class="wizard-hole-col">
          <div class="wizard-hole-num">${i+10}</div>
          <input type="number" class="wizard-hole-input" data-hole="${i+9}" data-field="par" value="${this.data.newCourse.par[i+9] || ''}" min="3" max="6" placeholder="P">
          <input type="number" class="wizard-hole-input" data-hole="${i+9}" data-field="hcp" value="${this.data.newCourse.hcp[i+9] || ''}" min="1" max="18" placeholder="H">
        </div>
      `);
    }

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Course Setup</h2>
        <p>Enter course details</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-section">
          <div class="wizard-section-title">Course Name</div>
          <input type="text" id="wizardCourseName" placeholder="Course name" value="${this.data.newCourse.name}" style="width:100%;margin-bottom:16px;">
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Front 9 (Par / Handicap)</div>
          <div class="wizard-holes-grid">${frontHoles.join('')}</div>
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Back 9 (Par / Handicap)</div>
          <div class="wizard-holes-grid">${backHoles.join('')}</div>
        </div>
        <div class="wizard-section">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="wizardSavePreset" checked>
            <span>Save as course preset</span>
          </label>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardCourseSetupBack">Back</button>
        <button class="btn primary" id="wizardCourseSetupNext">Next</button>
      </div>
    `;

    setTimeout(() => {
      // Course name input
      document.getElementById('wizardCourseName').oninput = (e) => {
        this.data.newCourse.name = e.target.value;
      };

      // Par and handicap inputs
      div.querySelectorAll('.wizard-hole-input').forEach(input => {
        input.oninput = (e) => {
          const hole = parseInt(e.target.dataset.hole);
          const field = e.target.dataset.field;
          const val = parseInt(e.target.value) || 0;
          this.data.newCourse[field][hole] = val;
        };
      });

      document.getElementById('wizardCourseSetupBack').onclick = () => {
        this.step = 'course';
        this.render();
      };

      document.getElementById('wizardCourseSetupNext').onclick = () => {
        // Apply course to state
        State.data.course.name = this.data.newCourse.name || 'New Course';
        State.data.course.par = [...this.data.newCourse.par];
        State.data.course.hcp = [...this.data.newCourse.hcp];

        // Save as preset if checked
        if (document.getElementById('wizardSavePreset').checked && this.data.newCourse.name.trim()) {
          State.presets[this.data.newCourse.name.trim()] = {
            par: [...this.data.newCourse.par],
            hcp: [...this.data.newCourse.hcp]
          };
        }

        this.step = 'players';
        this.render();
      };
    }, 0);

    return div;
  },

  renderPlayers() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    const playersHtml = this.data.players.map((p, i) => `
      <div class="wizard-player-row">
        <input type="text" placeholder="Player ${i+1} name" value="${p.name}" data-idx="${i}" data-field="name">
        <input type="number" placeholder="HCP" value="${p.handicap || ''}" data-idx="${i}" data-field="handicap" min="0" max="54">
        ${i >= 2 ? `<button class="delete-btn" data-idx="${i}">&times;</button>` : '<div></div>'}
      </div>
    `).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Who's Playing?</h2>
        <p>Add players and their course handicaps</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-player-row header">
          <div>Name</div>
          <div>Handicap</div>
          <div></div>
        </div>
        <div id="wizardPlayersList">${playersHtml}</div>
        ${this.data.players.length < 5 ? '<button class="wizard-add-btn" id="wizardAddPlayer">+ Add Player</button>' : ''}
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardPlayersBack">Back</button>
        <button class="btn primary" id="wizardPlayersNext">Next</button>
      </div>
    `;

    setTimeout(() => {
      div.querySelectorAll('input[data-field="name"]').forEach(input => {
        input.oninput = (e) => {
          this.data.players[parseInt(e.target.dataset.idx)].name = e.target.value;
        };
      });

      div.querySelectorAll('input[data-field="handicap"]').forEach(input => {
        input.oninput = (e) => {
          this.data.players[parseInt(e.target.dataset.idx)].handicap = parseInt(e.target.value) || 0;
        };
      });

      div.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = (e) => {
          this.data.players.splice(parseInt(e.target.dataset.idx), 1);
          this.render();
        };
      });

      const addBtn = document.getElementById('wizardAddPlayer');
      if (addBtn) {
        addBtn.onclick = () => {
          this.data.players.push({name:'', handicap:0});
          this.render();
        };
      }

      document.getElementById('wizardPlayersNext').onclick = () => {
        const validPlayers = this.data.players.filter(p => p.name.trim());
        if (validPlayers.length < 2) {
          Err.toast('Need at least 2 players');
          return;
        }
        // Auto-assign teams for first game if not already set
        const g = this.getCurrentGame();
        if (g.teamA.length === 0 && g.teamB.length === 0) {
          const pids = validPlayers.map((p, i) => 'p' + (i+1));
          if (pids.length >= 4) {
            g.teamA = [pids[0], pids[1]];
            g.teamB = [pids[2], pids[3]];
          } else if (pids.length === 3) {
            g.teamA = [pids[0]];
            g.teamB = [pids[1]];
          } else {
            g.teamA = [pids[0]];
            g.teamB = [pids[1]];
          }
        }
        this.step = 'game';
        this.render();
      };

      document.getElementById('wizardPlayersBack').onclick = () => {
        this.step = 'course';
        this.render();
      };
    }, 0);

    return div;
  },

  renderGame() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';
    const g = this.getCurrentGame();
    const validPlayers = this.data.players.filter(p => p.name.trim()).map((p, i) => ({id: 'p'+(i+1), name: p.name}));

    const teamAHtml = g.teamA.map(pid => {
      const p = validPlayers.find(x => x.id === pid);
      return p ? `<span class="wizard-player-chip team-a" data-pid="${pid}">${p.name}</span>` : '';
    }).join('');

    const teamBHtml = g.teamB.map(pid => {
      const p = validPlayers.find(x => x.id === pid);
      return p ? `<span class="wizard-player-chip team-b" data-pid="${pid}">${p.name}</span>` : '';
    }).join('');

    const unassigned = validPlayers.filter(p => !g.teamA.includes(p.id) && !g.teamB.includes(p.id));
    const unassignedHtml = unassigned.map(p => `<span class="wizard-player-chip" data-pid="${p.id}">${p.name}</span>`).join('');

    // Build game tabs
    const gameTabsHtml = this.data.games.map((game, idx) => {
      const isActive = idx === this.currentGameIndex;
      const canDelete = this.data.games.length > 1;
      const gameLabel = game.gameType === 'vegas' ? 'Vegas' : 'Nassau';
      return `<span class="wizard-game-tab ${isActive ? 'active' : ''}" data-game-idx="${idx}">
        Game ${idx + 1}${canDelete && isActive ? '<span class="delete-game" data-delete-idx="' + idx + '">&times;</span>' : ''}
      </span>`;
    }).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Game Setup</h2>
        <div class="wizard-game-tabs">${gameTabsHtml}<span class="wizard-game-tab" data-add-game="1">+ New</span></div>
      </div>
      <div class="wizard-content">
        <div class="wizard-section">
          <div class="wizard-section-title">Game Type</div>
          <div class="wizard-option ${g.gameType==='nassau'?'selected':''}" data-type="nassau">
            <input type="radio" name="gameType" ${g.gameType==='nassau'?'checked':''}>
            <div><strong>Nassau</strong><br><span class="muted">Front 9, Back 9, Overall</span></div>
          </div>
          <div class="wizard-option ${g.gameType==='vegas'?'selected':''}" data-type="vegas">
            <input type="radio" name="gameType" ${g.gameType==='vegas'?'checked':''}>
            <div><strong>Vegas</strong><br><span class="muted">2v2 with flip scoring</span></div>
          </div>
        </div>

        <div class="wizard-section">
          <div class="wizard-section-title">Teams (tap to reassign)</div>
          <div class="grid grid-2" style="gap:12px;">
            <div class="wizard-team-zone" id="teamAZone">
              <h4>Team A</h4>
              ${teamAHtml || '<span class="muted">Tap players below</span>'}
            </div>
            <div class="wizard-team-zone" id="teamBZone">
              <h4>Team B</h4>
              ${teamBHtml || '<span class="muted">Tap players below</span>'}
            </div>
          </div>
          ${unassignedHtml ? `<div style="margin-top:12px;text-align:center;"><div class="muted" style="font-size:12px;margin-bottom:6px;">Not in game:</div>${unassignedHtml}</div>` : ''}
        </div>

        <div class="wizard-section">
          <div class="wizard-section-title">Handicap Mode</div>
          <div class="wizard-option ${g.handicapMode==='full'?'selected':''}" data-hcp="full">
            <input type="radio" name="hcpMode" ${g.handicapMode==='full'?'checked':''}>
            <div><strong>Full Strokes</strong><br><span class="muted">Everyone gets their full handicap</span></div>
          </div>
          <div class="wizard-option ${g.handicapMode==='off_low'?'selected':''}" data-hcp="off_low">
            <input type="radio" name="hcpMode" ${g.handicapMode==='off_low'?'checked':''}>
            <div><strong>Off the Low</strong><br><span class="muted">Reduce all by lowest handicap</span></div>
          </div>
          <div class="wizard-option ${g.handicapMode==='team_delta'?'selected':''}" data-hcp="team_delta">
            <input type="radio" name="hcpMode" ${g.handicapMode==='team_delta'?'checked':''}>
            <div><strong>Team Delta</strong><br><span class="muted">High player on high team gets difference</span></div>
          </div>
        </div>

        <div class="wizard-section">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="wizardJunkToggle" ${g.withJunk?'checked':''} style="width:20px;height:20px;">
            <span>Include Junk (birdies, sandies, etc.)</span>
          </label>
        </div>

        <div class="wizard-section">
          <div class="wizard-section-title">${g.gameType==='vegas'?'$/Point':'Stakes'}</div>
          <div class="grid grid-3" style="gap:8px;">
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Front</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesFront" value="${(g.gameType==='vegas'?g.pointValue.front:g.stakes.front).toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Back</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesBack" value="${(g.gameType==='vegas'?g.pointValue.back:g.stakes.back).toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            ${g.gameType==='nassau'?`
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Overall</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesOverall" value="${g.stakes.overall.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            `:'<div></div>'}
          </div>
        </div>

        <div class="wizard-section" id="wizardJunkStakes" style="${g.withJunk?'':'display:none;'}">
          <div class="wizard-section-title">Junk $/point</div>
          <div class="grid grid-2" style="gap:8px;">
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Front</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardJunkFront" value="${g.junkValue.front.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Back</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardJunkBack" value="${g.junkValue.back.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardGameBack">Back</button>
        <button class="btn" id="wizardGameNext">+ Add Game</button>
        <button class="btn primary" id="wizardStartScoring" style="background:var(--success);border-color:var(--success);">Start Scoring</button>
      </div>
    `;

    setTimeout(() => {
      // Game tabs - switch between games
      div.querySelectorAll('[data-game-idx]').forEach(tab => {
        tab.onclick = (e) => {
          if (e.target.classList.contains('delete-game')) return;
          this.switchToGame(parseInt(tab.dataset.gameIdx));
        };
      });

      // Add new game tab
      div.querySelectorAll('[data-add-game]').forEach(tab => {
        tab.onclick = () => this.addNewGame();
      });

      // Delete game buttons
      div.querySelectorAll('[data-delete-idx]').forEach(btn => {
        btn.onclick = (e) => {
          e.stopPropagation();
          this.deleteGame(parseInt(btn.dataset.deleteIdx));
        };
      });

      // Game type
      div.querySelectorAll('[data-type]').forEach(opt => {
        opt.onclick = () => {
          g.gameType = opt.dataset.type;
          this.render();
        };
      });

      // Handicap mode
      div.querySelectorAll('[data-hcp]').forEach(opt => {
        opt.onclick = () => {
          g.handicapMode = opt.dataset.hcp;
          this.render();
        };
      });

      // Team assignment (max 2 per team)
      div.querySelectorAll('.wizard-player-chip').forEach(chip => {
        chip.onclick = () => {
          const pid = chip.dataset.pid;
          // Cycle: unassigned -> A -> B -> unassigned (max 2 per team)
          if (g.teamA.includes(pid)) {
            g.teamA = g.teamA.filter(x => x !== pid);
            if (g.teamB.length < 2) g.teamB.push(pid);
          } else if (g.teamB.includes(pid)) {
            g.teamB = g.teamB.filter(x => x !== pid);
          } else {
            // Unassigned - try to add to Team A first, then B
            if (g.teamA.length < 2) g.teamA.push(pid);
            else if (g.teamB.length < 2) g.teamB.push(pid);
          }
          this.render();
        };
      });

      // Junk toggle
      document.getElementById('wizardJunkToggle').onchange = (e) => {
        g.withJunk = e.target.checked;
        document.getElementById('wizardJunkStakes').style.display = g.withJunk ? '' : 'none';
      };

      // Stakes inputs
      document.getElementById('wizardStakesFront').onchange = (e) => {
        const v = parseFloat(e.target.value) || 0;
        if (g.gameType === 'vegas') g.pointValue.front = v;
        else g.stakes.front = v;
      };
      document.getElementById('wizardStakesBack').onchange = (e) => {
        const v = parseFloat(e.target.value) || 0;
        if (g.gameType === 'vegas') g.pointValue.back = v;
        else g.stakes.back = v;
      };
      const overallInput = document.getElementById('wizardStakesOverall');
      if (overallInput) {
        overallInput.onchange = (e) => {
          g.stakes.overall = parseFloat(e.target.value) || 0;
        };
      }
      document.getElementById('wizardJunkFront').onchange = (e) => {
        g.junkValue.front = parseFloat(e.target.value) || 0;
      };
      document.getElementById('wizardJunkBack').onchange = (e) => {
        g.junkValue.back = parseFloat(e.target.value) || 0;
      };

      // Navigation
      document.getElementById('wizardGameNext').onclick = () => {
        if (g.teamA.length === 0 || g.teamB.length === 0) {
          Err.toast('Assign players to both teams');
          return;
        }
        this.addNewGame();
      };

      document.getElementById('wizardStartScoring').onclick = () => {
        // Validate all games have teams assigned
        for (let i = 0; i < this.data.games.length; i++) {
          const game = this.data.games[i];
          if (game.teamA.length === 0 || game.teamB.length === 0) {
            Err.toast(`Game ${i+1} needs teams assigned`);
            this.switchToGame(i);
            return;
          }
        }
        this.finish();
      };

      document.getElementById('wizardGameBack').onclick = () => {
        this.step = 'players';
        this.render();
      };
    }, 0);

    return div;
  }
};

// === UI ===
const UI = {
  playerName(id) {
    const p = State.data.players.find(x => x.id === id);
    return p ? p.name : id;
  },

  gameLabel(g) {
    const abbr = (pid, used) => {
      const nm = this.playerName(pid);
      if (/[0-9]/.test(nm)) {
        const s = nm.toUpperCase();
        if (!used[s]) { used[s] = true; return s; }
      }
      const base = nm.replace(/[^A-Za-z]/g, '').toUpperCase() || String(pid).toUpperCase();
      for (let len = 1; len <= Math.min(3, base.length); len++) {
        const c = base.slice(0, len);
        if (!used[c]) { used[c] = true; return c; }
      }
      const stem = base.slice(0, 2) || base;
      let n = 2;
      while (used[stem + n]) n++;
      used[stem + n] = true;
      return stem + n;
    };
    const used = {};
    const a1 = g.teamA && g.teamA[0] ? abbr(g.teamA[0], used) : '';
    const a2 = g.teamA && g.teamA[1] ? abbr(g.teamA[1], used) : '';
    const b1 = g.teamB && g.teamB[0] ? abbr(g.teamB[0], used) : '';
    const b2 = g.teamB && g.teamB[1] ? abbr(g.teamB[1], used) : '';
    const left = (a1 && a2) ? `${a1}/${a2}` : (a1 || a2 || 'Team A');
    const right = (b1 && b2) ? `${b1}/${b2}` : (b1 || b2 || 'Team B');
    
    if (g.gameType === 'vegas') {
      return `Vegas: ${left} vs ${right}`;
    } else {
      const mode = g.scoringMode === 'low_net' ? 'Best Ball' : 'Hi/Low';
      return `${mode}: ${left} vs ${right}`;
    }
  },

  render() {
    if (State.locks > 0) return;
    this.renderTabs();
    const root = document.getElementById('app');
    root.innerHTML = '';
    let view;
    switch (State.data.tab) {
      case 'setup': view = this.setup(); break;
      case 'scores': view = this.scores(); break;
      case 'junk': view = this.junk(); break;
      case 'status': view = this.status(); break;
      case 'game': view = this.game(); break;
      case 'transactions': view = this.transactions(); break;
      case 'highlights': view = this.highlights(); break;
      case 'rules': view = this.rules(); break;
      default: view = h('div', {class:'card'}, 'Unknown tab');
    }
    // Header always visible now (contains hamburger menu)
    root.appendChild(view);
  },

  renderTabs() {
    const tabs = [
      ['scores','Scores'],['junk','Junk'],
      ['status','Status'],['game','Game Details'],['transactions','Payments'],['highlights','Highlights'],['rules','Rules'],
      ['setup','Setup (Advanced)']
    ];

    // Populate menu navigation
    const menuNav = document.getElementById('menuNav');
    if (menuNav) {
      menuNav.innerHTML = '';
      tabs.forEach(([id, label]) => {
        const btn = document.createElement('button');
        btn.className = `menu-item ${State.data.tab === id ? 'active' : ''}`;
        btn.textContent = label;
        btn.onclick = () => {
          State.data.tab = id;
          this.closeMenu();
          State.scheduleRender();
        };
        menuNav.appendChild(btn);
      });
    }

    // Hide old tabs bar (keeping element for compatibility)
    const tabsEl = document.getElementById('tabs');
    if (tabsEl) tabsEl.style.display = 'none';
  },

  openMenu() {
    document.getElementById('menuOverlay').classList.add('open');
    document.getElementById('slideMenu').classList.add('open');
    document.body.style.overflow = 'hidden';
  },

  closeMenu() {
    document.getElementById('menuOverlay').classList.remove('open');
    document.getElementById('slideMenu').classList.remove('open');
    document.body.style.overflow = '';
  },

  initMenu() {
    document.getElementById('menuToggle').onclick = () => this.openMenu();
    document.getElementById('menuClose').onclick = () => this.closeMenu();
    document.getElementById('menuOverlay').onclick = () => this.closeMenu();
  },

  setup() {
    // Players
    const playerInputs = State.data.players.map(p => 
      h('div', {style:'display:grid;grid-template-columns:64px 1fr;gap:8px;'}, [
        h('span', {class:'muted',style:'text-align:right;'}, p.id),
        h('input', {
          type:'text', value:p.name,
          onfocus:() => State.begin(),
          oninput:(e) => p.name = e.target.value,
          onblur:() => State.end()
        })
      ])
    );

    // Course
    const presetSel = h('select', {
      onchange:(e) => {
        const pr = State.presets[e.target.value];
        if (pr) {
          State.data.course.hcp = [...pr.hcp];
          State.data.course.par = [...pr.par];
          State.data.course.name = e.target.value;
          State.scheduleSave();
          State.scheduleRender();
        }
      }
    });
    Object.keys(State.presets).forEach(nm => {
      presetSel.appendChild(h('option', {value:nm, selected:nm===State.data.course.name}, nm));
    });

    const hcpHead = [h('th',{class:'sticky'},'HOLE')];
    for (let i = 0; i < 18; i++) hcpHead.push(h('th',{},String(i+1)));
    const parRow = [h('td',{class:'sticky'},'PAR')];
    for (let i = 0; i < 18; i++) {
      parRow.push(h('td',{},[
        h('input',{
          type:'tel',inputmode:'numeric',value:State.data.course.par[i]||4,
          style:'width:56px;text-align:center;',
          onfocus:()=>State.begin(),
          oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
          onblur:(e)=>{
            const v = Math.min(6, Math.max(3, parseInt(e.target.value)||4));
            State.data.course.par[i] = v;
            e.target.value = String(v);
            State.end();
          }
        })
      ]));
    }
    const hcpRow = [h('td',{class:'sticky'},'HCP')];
    for (let i = 0; i < 18; i++) {
      hcpRow.push(h('td',{},[
        h('input',{
          type:'tel',inputmode:'numeric',value:State.data.course.hcp[i],
          style:'width:56px;text-align:center;',
          onfocus:()=>State.begin(),
          oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
          onblur:(e)=>{
            const v = Math.min(18, Math.max(1, parseInt(e.target.value)||1));
            State.data.course.hcp[i] = v;
            e.target.value = String(v);
            State.end();
          }
        })
      ]));
    }

    const courseCard = h('div',{class:'card'},[
      h('div',{class:'pill'},'Course Handicap'),
      h('div',{style:'margin-top:8px;'},presetSel),
      h('div',{class:'note',style:'margin-top:6px;'},`Loaded: ${State.data.course.name}`),
      h('div',{class:'card scroll',style:'margin-top:8px;'},
        h('table',{},[
          h('thead',{},[h('tr',{},hcpHead)]),
          h('tbody',{},[h('tr',{},parRow),h('tr',{},hcpRow)])
        ])
      ),
      h('button',{class:'btn small',style:'margin-top:8px;',onclick:()=>{
        const nm = prompt('Name this preset:');
        if (!nm) return;
        State.presets[nm] = {hcp:[...State.data.course.hcp], par:[...State.data.course.par]};
        State.data.course.name = nm;
        State.scheduleSave();
        State.scheduleRender();
        Err.toast('Preset saved');
      }},'Save as New Preset')
    ]);

    // Games
    const gamesHeader = h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
      h('div',{class:'pill'},'Games'),
      h('button',{class:'btn small',onclick:()=>{
        const ng = Game.create(true);
        State.data.games.push(ng);
        State.scheduleSave();
        State.scheduleRender();
      }},'Add Game')
    ]);

    const gameCards = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      
      const teamBtns = (key) => {
        const team = key==='A'?g.teamA:g.teamB;
        const btns = State.data.players.map(p => {
          const on = team.indexOf(p.id)>=0;
          const full = !on && team.length >= g.teamSize;
          return h('button',{
            class:`btn small ${on?'primary':''}`,
            disabled:full,
            onclick:()=>{
              const i = team.indexOf(p.id);
              if (i>=0) team.splice(i,1);
              else if (team.length < g.teamSize) team.push(p.id);
              State.scheduleSave();
              State.scheduleRender();
            }
          },p.name);
        });
        return h('div',{class:'row'},btns);
      };


      const gameTypeSelector = () => h('div',{style:'margin:12px 0;'},[
        h('div',{class:'muted'},'Game Type'),
        h('div',{class:'row',style:'margin-top:6px;'},[
          h('label',{class:'nowrap',style:'margin-right:12px;'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='nassau',
              onchange:()=>{g.gameType='nassau';State.scheduleSave();State.scheduleRender();}}),
            ' Nassau'
          ]),
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='vegas',
              onchange:()=>{
                g.gameType='vegas';
                g.teamA=g.teamA.slice(0,2);
                g.teamB=g.teamB.slice(0,2);
                State.scheduleSave();
                State.scheduleRender();
              }}),
            ' Vegas'
          ])
        ])
      ]);

      const strokesEditor = () => {
        const teamRow = (lbl, ids) => {
          const grid = h('div',{style:'display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(96px,1fr));'});
          ids.forEach(pid => {
            grid.appendChild(h('div',{style:'display:flex;flex-direction:column;gap:6px;'},[
              h('div',{class:'muted',style:'text-align:center;font-size:12px;'},this.playerName(pid)),
              h('input',{
                type:'tel',inputmode:'numeric',value:g.strokesCount[pid]||0,
                style:'width:100%;text-align:center;padding:8px 10px;',
                onfocus:()=>State.begin(),
                oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
                onblur:(e)=>{
                  g.strokesCount[pid]=parseInt(e.target.value)||0;
                  e.target.value=String(g.strokesCount[pid]);
                  State.end();
                }
              })
            ]));
          });
          return h('div',{},[h('div',{class:'muted',style:'margin:6px 0 8px;'},lbl),grid]);
        };
        const body = [];
        if (g.teamA.length) body.push(teamRow('Team A:',g.teamA));
        if (g.teamB.length) body.push(teamRow('Team B:',g.teamB));
        if (!g.teamA.length && !g.teamB.length) body.push(h('div',{class:'note'},'Pick players to edit strokes'));
        else body.push(h('div',{class:'note'},'Strokes apply on HCP 1â€¦n'));
        return h('div',{class:'card'},[h('div',{class:'pill'},'Strokes'),h('div',{},body)]);
      };

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{},[
              h('button',{class:'btn small',onclick:()=>{
                State.data.tab='scores';
                State.scheduleRender();
              }},'Go to SCORES'),
              h('button',{class:'btn small',style:'margin-left:6px;',onclick:()=>{
                const i = State.data.games.indexOf(g);
                if (i>=0) State.data.games.splice(i,1);
                if (!State.data.games.length) State.data.games.push(Game.create());
                State.scheduleSave();
                State.scheduleRender();
              }},'Delete')
            ])
          ]),
          
          gameTypeSelector(),
          
          g.gameType === 'nassau' ? h('div',{},[h('div',{class:'game-options-row',style:'margin:6px 0;'},[
            h('div',{},[
              h('div',{class:'muted nowrap'},'Nassau Scoring'),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`mode_${g.id}`,checked:g.scoringMode==='hi_low',
                  onchange:()=>{g.scoringMode='hi_low';State.scheduleSave();State.scheduleRender();}}),
                ' Hi/Low'
              ]),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`mode_${g.id}`,checked:g.scoringMode==='low_net',
                  onchange:()=>{g.scoringMode='low_net';State.scheduleSave();State.scheduleRender();}}),
                ' Best Ball'
              ])
            ]),
            h('div',{},[
              h('div',{class:'muted nowrap'},'Team Size'),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`ts_${g.id}`,checked:g.teamSize===2,
                  onchange:()=>{g.teamSize=2;State.scheduleSave();State.scheduleRender();}}),
                ' 2v2'
              ]),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`ts_${g.id}`,checked:g.teamSize===1,
                  onchange:()=>{g.teamSize=1;g.teamA=g.teamA.slice(0,1);g.teamB=g.teamB.slice(0,1);State.scheduleSave();State.scheduleRender();}}),
                ' 1v1'
              ])
            ])
          ]),
          g.scoringMode==='hi_low' && g.teamSize===1 ? h('div',{class:'note',style:'margin-top:4px;'},'Hi/Low needs 2v2. Using Best Ball until teams full.') : h('div',{}),
          h('div',{class:'grid grid-2'},[
            h('div',{},[h('div',{class:'muted'},`Team A (pick ${g.teamSize})`),teamBtns('A')]),
            h('div',{},[h('div',{class:'muted'},`Team B (pick ${g.teamSize})`),teamBtns('B')])
          ]),
          h('div',{class:'grid grid-3'},[
            h('div',{},[h('div',{class:'muted'},'Front $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.front,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.front=parseInt(e.target.value)||0;e.target.value=String(g.stakes.front);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Back $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.back,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.back=parseInt(e.target.value)||0;e.target.value=String(g.stakes.back);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Overall $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.overall,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.overall=parseInt(e.target.value)||0;e.target.value=String(g.stakes.overall);State.end();}})]),
          ]),
          h('div',{class:'grid grid-3'},[
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.front,onclick:(e)=>{g.autoPress.front=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN']),
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.back,onclick:(e)=>{g.autoPress.back=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN']),
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.overall,onclick:(e)=>{g.autoPress.overall=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN'])
          ]),
          h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
            h('div',{class:'pill'},'Junk $/point'),
            h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
          ]),
]) : h('div',{}),

          g.gameType === 'vegas' ? h('div',{},[
            h('div',{class:'grid grid-2'},[
              h('div',{},[h('div',{class:'muted'},'Team A (pick 2)'),teamBtns('A')]),
              h('div',{},[h('div',{class:'muted'},'Team B (pick 2)'),teamBtns('B')])
            ]),
            h('div',{class:'grid grid-2',style:'margin-top:12px;'},[
              h('div',{},[h('div',{class:'muted'},'Front $/pt'),h('input',{type:'number',step:'0.25',value:g.pointValue.front,onfocus:()=>State.begin(),onblur:(e)=>{g.pointValue.front=parseFloat(e.target.value)||1;State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back $/pt'),h('input',{type:'number',step:'0.25',value:g.pointValue.back,onfocus:()=>State.begin(),onblur:(e)=>{g.pointValue.back=parseFloat(e.target.value)||1;State.end();}})]),
            ]),
            h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
              h('div',{class:'pill'},'Junk $/point'),
              h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
            ]),
            h('div',{class:'note',style:'margin-top:8px;'},'Flip if: opponent birdie, OR no one on your team has net par or better')
          ]) : h('div',{}),

          strokesEditor(),
          h('div',{class:'note'},'Scores tab shows GROSS. Net is auto from strokes + course HCP.')
        ])
      ]);
    });

    return h('div',{},[
      h('div',{class:'card'},[h('div',{class:'pill'},'Players'),h('div',{},playerInputs)]),
      courseCard,
      h('div',{},[gamesHeader,...gameCards])
    ]);
  },

  scores() {
    const g = State.data.games[0];
    if (!g) return h('div',{class:'card'},'No game. Add one in Setup.');

    const last = Game.getLastScored();
    const updateSums = (pid) => {
      const arr = g.gross[pid];
      const f = Utils.sumRange(arr,0,8);
      const b = Utils.sumRange(arr,9,17);
      const t = (f==null && b==null)?null:((f||0)+(b||0));
      const fEl = document.getElementById(`sumF_${pid}`);
      const bEl = document.getElementById(`sumB_${pid}`);
      const tEl = document.getElementById(`sumT_${pid}`);
      if (fEl) fEl.textContent = f==null?'':String(f);
      if (bEl) bEl.textContent = b==null?'':String(b);
      if (tEl) tEl.textContent = t==null?'':String(t);
    };

    const createDots = (pid, hole) => {
      const dots = [];
      for (let gi = 0; gi < Math.min(6, State.data.games.length); gi++) {
        const gm = State.data.games[gi];
        const inA = (gm.teamA||[]).indexOf(pid)>=0;
        const inB = (gm.teamB||[]).indexOf(pid)>=0;
        if (!inA && !inB) continue;
        const s = Game.strokes(gm, pid, hole);
        if (s > 0) dots.push(h('span',{class:`dot g${gi+1}`}));
      }
      return dots.length ? h('span',{class:'dots'},dots) : null;
    };

    const head = [h('th',{class:'sticky'},'Hole')];
    for (let i = 0; i < 18; i++) head.push(h('th',{id:`col_h_${i}`},String(i+1)));
    head.push(h('th',{},'F'),h('th',{},'B'),h('th',{},'TOT'));

    const parRow = [h('th',{class:'sticky'},'Par')];
    for (let i = 0; i < 18; i++) parRow.push(h('th',{},String(State.data.course.par[i]||'')));
    parRow.push(h('th',{}),h('th',{}),h('th',{}));

    // Get score indicator class based on gross score vs par
    const getScoreClass = (score, par) => {
      if (score == null) return '';
      const diff = score - par;
      if (diff <= -2) return 'eagle';
      if (diff === -1) return 'birdie';
      if (diff === 0) return '';
      if (diff === 1) return 'bogey';
      return 'double-bogey';
    };

    const rows = State.data.players.map((p, ri) => {
      // Ensure gross array exists for this player
      if (!g.gross[p.id]) g.gross[p.id] = Utils.make18(null);
      const cells = [h('td',{class:'sticky'},p.name)];
      for (let hole = 0; hole < 18; hole++) {
        const tabIdx = (hole * State.data.players.length) + ri + 1;
        const score = g.gross[p.id][hole];
        const par = State.data.course.par[hole] || 4;
        const scoreClass = getScoreClass(score, par);
        cells.push(h('td',{},[
          h('div',{class:'cellWrap' + (scoreClass ? ' ' + scoreClass : '')},[
            h('input',{
              type:'tel',inputmode:'numeric',tabindex:tabIdx,
              value:score==null?'':String(score),
              style:'width:54px;text-align:center;',
              placeholder:'-',
              onfocus:()=>State.begin(),
              oninput:(e)=>{
                e.target.value = Utils.sanitize(e.target.value);
                const v = e.target.value===''?null:parseInt(e.target.value);
                State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = v; });
                // Update score indicator immediately
                const wrap = e.target.closest('.cellWrap');
                wrap.classList.remove('eagle','birdie','bogey','double-bogey');
                const cls = getScoreClass(v, par);
                if (cls) wrap.classList.add(cls);
                // Check if all players have scores for this hole - if so, update status bars
                const allHaveScore = State.data.players.every(pl => {
                  const s = g.gross[pl.id] && g.gross[pl.id][hole];
                  return s != null;
                });
                if (allHaveScore) {
                  updateStatusBars();
                }
              },
              onkeydown:(e)=>{
                if (e.key==='Enter') {
                  e.preventDefault();
                  let next = tabIdx + 1;
                  const maxCol = (hole+1)*State.data.players.length;
                  if (next > maxCol) {
                    if (hole+1 < 18) next = (hole+1)*State.data.players.length - (State.data.players.length-1);
                    else next = tabIdx;
                  }
                  const nextEl = document.querySelector(`input[tabindex="${next}"]`);
                  if (nextEl) nextEl.focus();
                }
              },
              onblur:(e)=>{
                const v = e.target.value===''?null:parseInt(e.target.value);
                if (v!==null && (v<MIN_SCORE || v>MAX_SCORE)) {
                  Err.show(`Invalid score ${v}. Use ${MIN_SCORE}-${MAX_SCORE}`);
                  e.target.value = '';
                  State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = null; });
                } else {
                  State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = v; });
                  e.target.value = v==null?'':String(v);
                }
                updateSums(p.id);
                State.end();
              }
            }),
            h('div',{class:'score-indicator'}),
            createDots(p.id, hole) || ''
          ])
        ]));
      }
      const arr = g.gross[p.id];
      const f = Utils.sumRange(arr,0,8);
      const b = Utils.sumRange(arr,9,17);
      const t = (f==null && b==null)?null:((f||0)+(b||0));
      cells.push(
        h('td',{id:`sumF_${p.id}`},f==null?'':String(f)),
        h('td',{id:`sumB_${p.id}`},b==null?'':String(b)),
        h('td',{id:`sumT_${p.id}`},t==null?'':String(t))
      );
      return h('tr',{},cells);
    });


    const tbl = h('table',{},[
      h('thead',{},[h('tr',{},head),h('tr',{},parRow)]),
      h('tbody',{},[...rows,...(State.data.games.filter(g => g.gameType === 'vegas').map((game,gi) => {
        const actualIdx = State.data.games.indexOf(game);
        const theme = `theme-g${(actualIdx%6)+1}`;
        const cells = [h('td',{class:'sticky press-label',style:'font-weight:600;'},UI.gameLabel(game))];
        for (let hole = 0; hole < 18; hole++) {
          const currentPress = game.presses[hole] || '';
          const sel = h('select',{
            class:'press-select',
            onchange:(e)=>{
              game.presses[hole] = e.target.value;
              State.scheduleSave();
              State.scheduleRender();
            }
          },[
            h('option',{value:'',selected:currentPress===''},'â€”'),
            h('option',{value:'press',selected:currentPress==='press'},'P'),
            h('option',{value:'blind',selected:currentPress==='blind'},'B')
          ]);
          cells.push(h('td',{},[sel]));
        }
        cells.push(h('td',{colspan:'3'}));
        return h('tr',{class:`press-row ${theme}`},cells);
      }))])
    ]);

    const scroller = h('div',{class:'card scroll',id:'scoresScroll'},tbl);

    setTimeout(()=>{
      try {
        if (last>=0) {
          const col = document.getElementById(`col_h_${last}`);
          const sc = document.getElementById('scoresScroll');
          if (col && sc) {
            const tgt = Math.max(0, col.offsetLeft - sc.clientWidth*0.2);
            sc.scrollLeft = tgt;
          }
        }
      } catch(e) {}
    },0);

    // Function to build status bars - called on render and on score updates
    const buildGameStatusRows = () => State.data.games.map((game, idx) => {
      const theme = `theme-g${(idx%6)+1}`;

      // Check if ANY scores have been entered
      const hasAnyScore = State.data.players.some(p => {
        const arr = game.gross[p.id] || [];
        return arr.some(score => score != null);
      });

      // Check if back 9 has any scores (hole 10+)
      const hasBack9Score = State.data.players.some(p => {
        const arr = game.gross[p.id] || [];
        return arr.slice(9).some(score => score != null);
      });

      if (!hasAnyScore) {
        return h('div',{class:theme,style:'margin-bottom:6px;'},[
          h('div',{class:'card',style:'padding:8px 12px;'},[
            h('div',{class:'row',style:'align-items:center;justify-content:space-between;gap:12px;'},[
              h('div',{class:'pill',style:'font-size:12px;'},UI.gameLabel(game)),
              h('div',{class:'muted',style:'font-size:14px;'},'No scores yet')
            ])
          ])
        ]);
      }

      let frontLine, backLine;

      if (game.gameType === 'vegas') {
        const result = Game.computeVegasResult(game);
        const fmtPts = (pts) => pts > 0 ? `+${pts}` : pts === 0 ? 'E' : String(pts);
        frontLine = `Front: ${fmtPts(result.frontPoints)} pts (${Utils.fmt(result.frontValue)}/ea)`;
        backLine = hasBack9Score ? `Back: ${fmtPts(result.backPoints)} pts (${Utils.fmt(result.backValue)}/ea)` : null;
      } else {
        const result = Game.computeResult(game);
        const seg = result.segments;
        // Format Nassau status: show each bet line result (always from Team A perspective)
        const fmtSeg = (s) => s.winners.join('/');
        frontLine = `Front: ${fmtSeg(seg.front)} (${Utils.fmt(seg.front.teamPayA)}/ea)`;
        backLine = hasBack9Score ? `Back: ${fmtSeg(seg.back)} (${Utils.fmt(seg.back.teamPayA)}/ea)` : null;
      }

      return h('div',{class:theme,style:'margin-bottom:6px;'},[
        h('div',{class:'card',style:'padding:8px 12px;'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;'},[
            h('div',{class:'pill',style:'font-size:12px;'},UI.gameLabel(game)),
            h('div',{style:'text-align:right;font-size:13px;'},[
              h('div',{},frontLine),
              backLine ? h('div',{style:'margin-top:2px;'},backLine) : ''
            ])
          ])
        ])
      ]);
    });

    // Update status bars without full re-render
    const updateStatusBars = () => {
      const container = document.getElementById('gameStatusBars');
      if (container) {
        container.innerHTML = '';
        buildGameStatusRows().forEach(el => container.appendChild(el));
      }
    };

    const gameStatusRows = buildGameStatusRows();

    const toggleBar = h('div',{class:'scoring-toggle'},[
      h('button',{class:'scoring-toggle-btn active',onclick:()=>{}},'Scores'),
      h('button',{class:'scoring-toggle-btn',onclick:()=>{State.data.tab='junk';State.scheduleRender();}},'Junk')
    ]);

    return h('div',{},[
      toggleBar,
      h('div',{class:'row',style:'align-items:center;justify-content:space-between;margin-bottom:8px;'},[
        h('div',{class:'pill'},'Entering GROSS for all players'),
        h('div',{class:'note'},'Press rows show below for Vegas games (Press=2x, Blind=4x)')
      ]),
      scroller,
      h('div',{id:'gameStatusBars',style:'margin-top:12px;'},gameStatusRows)
    ]);
  },

  junk() {
    const last = Game.getLastScored();
    const blocks = State.data.games.map((g, gi) => {
      const pids = [...(g.teamA||[]),...(g.teamB||[])];
      const theme = `theme-g${(gi%6)+1}`;
      const baseTab = gi * 10000;

      const createInput = (pid, hole, ri) => {
        if (!g.junkCounts[pid]) g.junkCounts[pid] = Utils.make18(0);
        let cur = g.junkCounts[pid][hole];
        if (!Number.isFinite(cur)) { cur = 0; g.junkCounts[pid][hole] = 0; }
        const disp = cur===0?'':String(cur);
        const badge = h('span',{class:'junkVal'},disp);
        const tabIdx = baseTab + (hole * pids.length) + ri + 1;
        const inp = h('input',{
          class:'junkBox',type:'text',inputmode:'numeric',autocomplete:'off',placeholder:'-',tabindex:tabIdx,value:disp,
          oninput:(e)=>{
            const dig = Utils.sanitize(e.target.value);
            if (dig !== e.target.value) e.target.value = dig;
            const v = dig===''?0:parseInt(dig);
            g.junkCounts[pid][hole] = v;
            badge.textContent = v===0?'':String(v);
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify({...State.data, presets:State.presets})); } catch(e) {}
          },
          onkeydown:(e)=>{
            if (e.key==='Enter') {
              e.preventDefault();
              let next = tabIdx + 1;
              const colEnd = baseTab + ((hole+1)*pids.length);
              if (next > colEnd) next = baseTab + ((hole+1)*pids.length - (pids.length-1));
              const nextEl = document.querySelector(`input[tabindex="${next}"]`);
              if (nextEl) nextEl.focus();
            }
          },
          onblur:(e)=>{
            const dig = Utils.sanitize(e.target.value);
            const v = dig===''?0:parseInt(dig);
            g.junkCounts[pid][hole] = v;
            e.target.value = v===0?'':String(v);
            badge.textContent = v===0?'':String(v);
            State.scheduleSave();
          }
        });
        return h('div',{class:'junkWrap'},[inp, badge]);
      };

      const head = [h('th',{class:'sticky'},'Hole')];
      for (let i = 0; i < 18; i++) head.push(h('th',{id:`junk_col_${gi}_${i}`},String(i+1)));

      const rows = pids.map((pid,ri) => {
        const cells = [h('td',{class:'sticky'},UI.playerName(pid))];
        for (let hole = 0; hole < 18; hole++) {
          cells.push(h('td',{},[createInput(pid, hole, ri)]));
        }
        return h('tr',{},cells);
      });

      const tbl = h('table',{},[
        h('thead',{},[h('tr',{},head)]),
        h('tbody',{},rows)
      ]);

      const scroller = h('div',{class:'card scroll',id:`junkScroll_${gi}`},tbl);

      if (last >= 0) {
        setTimeout(()=>{
          try {
            const col = document.getElementById(`junk_col_${gi}_${last}`);
            const sc = document.getElementById(`junkScroll_${gi}`);
            if (col && sc) {
              const tgt = Math.max(0, col.offsetLeft - sc.clientWidth*0.2);
              sc.scrollLeft = tgt;
            }
          } catch(e) {}
        },0);
      }

      return h('div',{class:theme},scroller);
    });

    const toggleBar = h('div',{class:'scoring-toggle'},[
      h('button',{class:'scoring-toggle-btn',onclick:()=>{State.data.tab='scores';State.scheduleRender();}},'Scores'),
      h('button',{class:'scoring-toggle-btn active',onclick:()=>{}},'Junk')
    ]);

    return h('div',{},[
      toggleBar,
      h('div',{class:'note',style:'margin-bottom:8px;'},'Sweeps (+3) Sweeps/Quads (+6) on last Par 3'),
      ...blocks
    ]);
  },

  status() {
    const blocks = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      
      if (g.gameType === 'vegas') {
        const result = Game.computeVegasResult(g);
        const teamANames = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
        const teamBNames = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');
        
        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`A: ${teamANames}  |  B: ${teamBNames}`),
            h('div',{style:'margin-top:12px;'},[
              h('div',{class:'muted'},'Front: ' + (result.frontPoints>0?'+':'') + result.frontPoints + ' pts = ' + Utils.fmt(result.frontValue)),
              h('div',{class:'muted',style:'margin-top:4px;'},'Back: ' + (result.backPoints>0?'+':'') + result.backPoints + ' pts = ' + Utils.fmt(result.backValue)),
              h('div',{class:'muted',style:'margin-top:4px;'},'Junk: ' + Utils.fmt(result.junkValue)),
              h('div',{style:'margin-top:8px;font-weight:700;'},'Total: ' + Utils.fmt(result.totalValue))
            ])
          ])
        ]);
      }
      
      const renderSeg = (lbl, start, end, autoKey) => {
        const stake = g.stakes[autoKey] || 0;
        const seg = Game.buildSegment(g, start, end, stake, g.autoPress[autoKey]);
        const diffs = [];
        for (let i = 0; i < 18; i++) diffs.push(Game.holeDiff(g, i));
        const calcCum = (line) => {
          let cum = 0, hasAny = false;
          for (let h = line.start; h <= line.end; h++) {
            if (diffs[h] != null) {
              cum += diffs[h];
              hasAny = true;
            }
          }
          return hasAny ? cum : null;
        };
        const bets = seg.lines.map(line => {
          const c = calcCum(line);
          if (c===null) return 'â€”';
          if (c>0) return `+${c}`;
          if (c<0) return String(c);
          return 'E';
        });
        const hasAny = bets.some(t => t !== 'â€”');
        const betsTxt = hasAny ? bets.join(' / ') : 'â€”';

        const sumJunk = (team) => {
          let tot = 0;
          team.forEach(pid => {
            const arr = g.junkCounts[pid] || [];
            for (let h = start; h <= end && h < 18; h++) tot += (arr[h]||0);
          });
          return tot;
        };
        const aJ = sumJunk(g.teamA||[]);
        const bJ = sumJunk(g.teamB||[]);

        return h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'muted'},lbl),
            h('div',{class:'pill'},[
              h('div',{},`Bets: ${betsTxt}`),
              h('div',{},`Junk: A=${aJ} B=${bJ}`)
            ])
          ])
        ]);
      };

      const aN = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
      const bN = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{class:'note'},'Positive = Team A')
          ]),
          h('div',{class:'note'},`A: ${aN||'â€”'}  |  B: ${bN||'â€”'}`),
          renderSeg('Front (1â€“9)',0,8,'front'),
          renderSeg('Back (10â€“18)',9,17,'back'),
          renderSeg('Overall (1â€“18)',0,17,'overall')
        ])
      ]);
    });

    return h('div',{},[
      h('div',{class:'note',style:'margin-bottom:8px;'},'Current match standings'),
      ...blocks
    ]);
  },

  game() {
    const blocks = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      
      // Check if any scores entered
      if (!Game.hasAnyScores(g)) {
        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'muted',style:'margin-top:12px;text-align:center;padding:20px;'},'No scores entered yet. Go to SCORES tab to enter scores.')
          ])
        ]);
      }
      
      if (g.gameType === 'vegas') {
        const result = Game.computeVegasResult(g);
        const teamANames = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
        const teamBNames = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Team A: ${teamANames}  |  Team B: ${teamBNames}`),
            h('div',{style:'margin-top:12px;'},[
              h('div',{class:'grid grid-2'},[
                h('div',{class:'card'},[
                  h('div',{class:'muted'},'Front'),
                  h('div',{},`${result.frontPoints>0?'+':''}${result.frontPoints} pts`),
                  h('div',{style:'font-weight:600;'},Utils.fmt(result.frontValue))
                ]),
                h('div',{class:'card'},[
                  h('div',{class:'muted'},'Back'),
                  h('div',{},`${result.backPoints>0?'+':''}${result.backPoints} pts`),
                  h('div',{style:'font-weight:600;'},Utils.fmt(result.backValue))
                ])
              ]),
              h('div',{class:'card',style:'margin-top:12px;'},[
                h('div',{class:'row',style:'justify-content:space-between;'},[
                  h('div',{class:'muted'},'Junk:'),
                  h('div',{style:'font-weight:600;'},Utils.fmt(result.junkValue))
                ])
              ]),
              h('div',{class:'card',style:'margin-top:12px;background:linear-gradient(135deg,rgba(59,130,246,0.1),rgba(22,163,74,0.1));'},[
                h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
                  h('div',{},[
                    h('div',{class:'muted'},'TOTAL TO TEAM A'),
                    h('div',{class:'muted',style:'font-size:11px;margin-top:2px;'},Utils.fmt(result.totalValue/2)+' per player')
                  ]),
                  h('div',{style:'font-size:24px;font-weight:700;',class:result.totalValue>0?'points-positive':'points-negative'},
                    Utils.fmt(result.totalValue))
                ])
              ])
            ])
          ])
        ]);
      }
      
      let res;
      try {
        res = Game.computeResult(g);
      } catch(e) {
        console.error('computeResult failed:', e);
        return h('div',{class:theme},[h('div',{class:'card'},[h('div',{},'Error calculating Nassau result: ' + e.message)])]);
      }

      const fmtTP = (tot, sz) => {
        const s = Math.max(1, sz||1);
        return `${Utils.fmt(tot)} / ${Utils.fmt(tot/s)}`;
      };

      const renderSeg = (lbl, segRes) => {
        const pills = segRes.lines.map((line, li) => {
          const typ = line.pressedBy ? 'Press' : 'Main';
          const holes = `${line.start+1}â€“${line.end+1}`;
          const win = segRes.winners[li];
          return h('div',{class:'pill'},`${typ} â€¢ ${holes} â€¢ ${win}`);
        });
        const teamTot = segRes.teamPayA;
        return h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{},lbl),
            h('div',{class:'muted'},`Net to Team A (Team/Player): ${fmtTP(teamTot,(g.teamA||[]).length)}`)
          ]),
          h('div',{class:'row'},pills)
        ]);
      };

      const aN = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
      const bN = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{class:'note'},'Positive = Team A')
          ]),
          h('div',{class:'note'},`A: ${aN||'â€”'}  |  B: ${bN||'â€”'}`),
          renderSeg('Front (1â€“9)',res.segments.front),
          renderSeg('Back (10â€“18)',res.segments.back),
          renderSeg('Overall (1â€“18)',res.segments.overall),
          h('div',{class:'card'},[h('div',{class:'pill'},`Junk to Team A (Team/Player): ${fmtTP(res.teamTotals.junk,(g.teamA||[]).length)}`)]),
          h('div',{class:'card',style:'background:linear-gradient(135deg,rgba(59,130,246,0.05),rgba(22,163,74,0.05));'},[
            h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
              h('div',{},[
                h('div',{style:'font-weight:600;'},'GAME TOTAL TO TEAM A'),
                h('div',{class:'muted',style:'font-size:12px;margin-top:2px;'},Utils.fmt(res.teamTotals.total/((g.teamA||[]).length||1))+' per player')
              ]),
              h('div',{style:'font-size:20px;font-weight:700;',class:res.teamTotals.total>0?'points-positive':'points-negative'},
                Utils.fmt(res.teamTotals.total))
            ])
          ])
        ])
      ]);
    });

    return h('div',{},blocks);
  },

  transactions() {
    const shareBtn = h('div',{style:'margin-bottom:12px;'},[
      h('button',{class:'btn small share',onclick:()=>this.share()},'Share Results')
    ]);

    const net = {};
    State.data.players.forEach(p => net[p.id] = 0);

    const perGameRows = State.data.games.map(g => {
      // Skip if no scores
      if (!Game.hasAnyScores(g)) {
        return h('li',{class:'muted'},`${this.gameLabel(g)}: No scores yet`);
      }
      
      let tot;
      if (g.gameType === 'vegas') {
        const res = Game.computeVegasResult(g);
        tot = res.totalValue;
      } else {
        const res = Game.computeResult(g);
        tot = res.teamTotals.total;
      }
      const szA = (g.teamA||[]).length || 1;
      const szB = (g.teamB||[]).length || 1;
      const aShare = szA ? tot/szA : 0;
      const bShare = szB ? -tot/szB : 0;
      (g.teamA||[]).forEach(id => net[id] += aShare);
      (g.teamB||[]).forEach(id => net[id] += bShare);
      return h('li',{},`${this.gameLabel(g)}: ${Utils.fmt(tot)} to Team A`);
    });

    const perPlayerRows = State.data.players.map(p => 
      h('li',{},`${p.name}: ${Utils.fmt(net[p.id])}`)
    );

    const xfers = this.calcTransfers(net);
    const xferRows = xfers.map(x => 
      h('li',{},`${UI.playerName(x.from)} â†’ ${UI.playerName(x.to)}: ${Utils.fmt(x.amount)}`)
    );

    const themed = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      return h('div',{class:theme},[h('div',{class:'card'},[h('div',{class:'pill'},this.gameLabel(g))])]);
    });

    return h('div',{},[
      shareBtn,
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Per-Game Totals (to Team A)'),
        perGameRows.length ? h('ul',{},perGameRows) : h('div',{class:'muted'},'No games yet.')
      ]),
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Per-Player Net (All Games + Junk)'),
        h('ul',{},perPlayerRows)
      ]),
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Least-Cash Transfers'),
        xfers.length ? h('ul',{},xferRows) : h('div',{class:'muted'},'All square.')
      ]),
      h('div',{},themed)
    ]);
  },

  rules() {
    return h('div',{style:'max-width:800px;margin:0 auto;'},[
      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Nassau'),
        h('p',{},'Traditional Nassau is three separate bets: Front 9, Back 9, and Overall 18.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Scoring'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Hi/Low: Each team\'s best and worst net scores combine'),
          h('li',{},'Best Ball: Each team\'s best net score counts')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Auto-Press'),
        h('p',{},'When a team falls 2-down in a bet, a new "press" bet automatically starts for the remaining holes at the same stake.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Junk'),
        h('p',{},'Optional side bets for: Birdies, Sandies (sand save par+), Greenies (closest on par 3), etc. Each junk point has a $ value.')
      ]),
      
      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Vegas'),
        h('p',{},'Two-digit scoring game where each team forms a number from their two net scores.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'How Numbers Form'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Normal: Low score = tens digit, High score = ones digit'),
          h('li',{},'Example: Team scores 4 and 5 â†’ Number is 45')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Reversal (The Flip)'),
        h('p',{},'Numbers reverse (high becomes tens digit) when:'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Any opponent makes gross birdie, OR'),
          h('li',{},'Any teammate makes net bogey or worse')
        ]),
        h('p',{},'Example: Team scores 4 and 5, but flips â†’ Number is 54'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Scoring'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Lower number wins the difference in points'),
          h('li',{},'Example: 45 vs 56 â†’ Lower team wins 11 points'),
          h('li',{},'Points convert to dollars using $/point values for Front and Back 9')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Presses'),
        h('p',{},'Set per hole to multiply points:'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Blank (â€”): 1x multiplier'),
          h('li',{},'Press (P): 2x multiplier'),
          h('li',{},'Blind (B): 4x multiplier')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Junk'),
        h('p',{},'Same as Nassau - optional side bets with $ values.')
      ]),
      
      h('div',{class:'card'},[
        h('h2',{style:'margin:0 0 12px 0;'},'App Tips'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Use SETUP to configure games and player handicaps'),
          h('li',{},'Enter gross scores in SCORES tab'),
          h('li',{},'Track junk in JUNK tab'),
          h('li',{},'STATUS shows live standings as you play'),
          h('li',{},'GAME shows final breakdown when complete'),
          h('li',{},'PAYMENTS calculates who owes what')
        ])
      ])
    ]);
  },

  calcTransfers(net) {
    const debt = [], cred = [];
    Object.entries(net).forEach(([id, amt]) => {
      if (Math.abs(amt) < 0.005) return;
      if (amt < 0) debt.push({id, amount:-amt});
      else cred.push({id, amount:amt});
    });
    debt.sort((a,b) => b.amount - a.amount);
    cred.sort((a,b) => b.amount - a.amount);

    const xfers = [];
    let i = 0, j = 0;
    while (i < debt.length && j < cred.length) {
      const d = debt[i], c = cred[j];
      const pay = Math.min(d.amount, c.amount);
      xfers.push({from:d.id, to:c.id, amount:pay});
      d.amount -= pay;
      c.amount -= pay;
      if (d.amount <= 0.005) i++;
      if (c.amount <= 0.005) j++;
    }
    return xfers;
  },

  showRoundCompleteModal() {
    // Build quick summary
    const net = {};
    State.data.players.forEach(p => net[p.id] = 0);
    State.data.games.forEach(g => {
      let tot;
      if (g.gameType === 'vegas') {
        const res = Game.computeVegasResult(g);
        tot = res.totalValue;
      } else {
        const res = Game.computeResult(g);
        tot = res.teamTotals.total;
      }
      const szA = (g.teamA||[]).length || 1;
      const szB = (g.teamB||[]).length || 1;
      const aShare = szA ? tot/szA : 0;
      const bShare = szB ? -tot/szB : 0;
      (g.teamA||[]).forEach(id => net[id] += aShare);
      (g.teamB||[]).forEach(id => net[id] += bShare);
    });

    const xfers = this.calcTransfers(net);
    let transfersHtml = '<p class="muted">All square!</p>';
    if (xfers.length) {
      transfersHtml = '<ul style="margin:0;padding-left:20px;">' +
        xfers.map(x => `<li>${this.playerName(x.from)} â†’ ${this.playerName(x.to)}: ${Utils.fmt(x.amount)}</li>`).join('') +
        '</ul>';
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal" style="max-width:340px;">
        <h2 style="text-align:center;margin-bottom:8px;">Round Complete!</h2>
        <p class="muted" style="text-align:center;margin-bottom:16px;">Great round! Here's the settlement:</p>
        <div style="background:var(--card);border-radius:8px;padding:12px;margin-bottom:16px;">
          <div style="font-weight:600;margin-bottom:8px;">Payments:</div>
          ${transfersHtml}
        </div>
        <div class="modal-actions" style="flex-direction:column;gap:8px;">
          <button class="btn primary" id="shareResultsBtn" style="width:100%;">Share Results</button>
          <button class="btn" id="viewPaymentsBtn" style="width:100%;">View Full Details</button>
          <button class="btn secondary" id="dismissCompleteBtn" style="width:100%;">Dismiss</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    document.getElementById('shareResultsBtn').onclick = () => {
      overlay.remove();
      this.share();
    };
    document.getElementById('viewPaymentsBtn').onclick = () => {
      overlay.remove();
      State.data.tab = 'transactions';
      State.scheduleRender();
    };
    document.getElementById('dismissCompleteBtn').onclick = () => overlay.remove();
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  share() {
    try {
      const lines = ['Round Summary from Bunch Bets:',''];
      lines.push('Player Scores:');
      State.data.players.forEach(p => {
        const g = State.data.games[0];
        const arr = g.gross[p.id] || [];
        const f = Utils.sumRange(arr,0,8);
        const b = Utils.sumRange(arr,9,17);
        const t = (f==null && b==null)?null:((f||0)+(b||0));
        lines.push(`  ${p.name}: ${f??'-'} / ${b??'-'} / ${t??'-'}`);
      });
      lines.push('');

      State.data.games.forEach(g => {
        if (g.gameType === 'vegas') {
          const res = Game.computeVegasResult(g);
          lines.push(this.gameLabel(g));
          lines.push(`  Front:   ${Utils.fmt(res.frontValue)}`);
          lines.push(`  Back:    ${Utils.fmt(res.backValue)}`);
          lines.push(`  Junk:    ${Utils.fmt(res.junkValue)}`);
          lines.push(`  Total:   ${Utils.fmt(res.totalValue)}`);
          lines.push('');
        } else {
          const res = Game.computeResult(g);
          lines.push(this.gameLabel(g));
          lines.push(`  Front:   ${Utils.fmt(res.teamTotals.front)}`);
          lines.push(`  Back:    ${Utils.fmt(res.teamTotals.back)}`);
          lines.push(`  Overall: ${Utils.fmt(res.teamTotals.overall)}`);
          lines.push(`  Junk:    ${Utils.fmt(res.teamTotals.junk)}`);
          lines.push(`  Total:   ${Utils.fmt(res.teamTotals.total)}`);
          lines.push('');
        }
      });

      const net = {};
      State.data.players.forEach(p => net[p.id] = 0);
      State.data.games.forEach(g => {
        let tot;
        if (g.gameType === 'vegas') {
          const res = Game.computeVegasResult(g);
          tot = res.totalValue;
        } else {
          const res = Game.computeResult(g);
          tot = res.teamTotals.total;
        }
        const szA = (g.teamA||[]).length || 1;
        const szB = (g.teamB||[]).length || 1;
        const aShare = szA ? tot/szA : 0;
        const bShare = szB ? -tot/szB : 0;
        (g.teamA||[]).forEach(id => net[id] += aShare);
        (g.teamB||[]).forEach(id => net[id] += bShare);
      });

      lines.push('Per-Player Net:');
      State.data.players.forEach(p => lines.push(`  ${p.name}: ${Utils.fmt(net[p.id])}`));

      const xfers = this.calcTransfers(net);
      if (xfers.length) {
        lines.push('');
        lines.push('Transfers:');
        xfers.forEach(x => lines.push(`  ${UI.playerName(x.from)} â†’ ${UI.playerName(x.to)} : ${Utils.fmt(x.amount)}`));
      }

      const txt = lines.join('\n');

      if (navigator.share) {
        navigator.share({text:txt}).catch(() => alert(txt));
      } else if (/Mobi|Android/i.test(navigator.userAgent)) {
        window.location.href = `sms:?&body=${encodeURIComponent(txt)}`;
      } else {
        alert(txt);
      }
    } catch(e) {
      Err.show('Share failed: ' + e.message);
    }
  },

  highlights() {
    const minInp = h('input',{
      type:'number',value:State.data.settings.thMin,style:'width:80px;padding:4px 6px;',
      oninput:(e)=>{State.data.settings.thMin=parseFloat(e.target.value)||0;State.scheduleRender();}
    });
    const topInp = h('input',{
      type:'number',value:State.data.settings.thTop,style:'width:64px;padding:4px 6px;',
      oninput:(e)=>{State.data.settings.thTop=Math.max(1,parseInt(e.target.value)||1);State.scheduleRender();}
    });

    const toolbar = h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
      h('div',{class:'pill'},'Highlights (hole vs zero)'),
      h('div',{},[
        h('label',{},['Min $ ',minInp]),
        h('label',{style:'margin-left:8px;'},['Top ',topInp])
      ])
    ]);

    const all = this.buildHighlights()
      .filter(x => x.value >= State.data.settings.thMin)
      .slice(0, State.data.settings.thTop);

    const content = all.length 
      ? h('ul',{}, all.map(x => h('li',{}, x.text)))
      : h('div',{class:'muted',style:'padding:8px 0;'},'No highlights yet.');

    return h('div',{},[h('div',{class:'card'},[toolbar, content])]);
  },

  buildHighlights() {
    const equalizeHole = (g, hole) => {
      const g2 = Utils.clone(g);
      const ids = [...(g2.teamA||[]),...(g2.teamB||[])];
      ids.forEach(pid => {
        const s = Game.strokes(g2, pid, hole) || 0;
        if (!g2.gross[pid]) g2.gross[pid] = Utils.make18(null);
        g2.gross[pid][hole] = s + 100;
        if (!g2.junkCounts[pid]) g2.junkCounts[pid] = Utils.make18(0);
        g2.junkCounts[pid][hole] = 0;
      });
      return g2;
    };

    const aggTotal = (games) => {
      let tot = 0;
      games.forEach(g => {
        if (g.gameType === 'vegas') {
          tot += Game.computeVegasResult(g).totalValue;
        } else {
          tot += Game.computeResult(g).teamTotals.total;
        }
      });
      return tot;
    };

    const actual = aggTotal(State.data.games);
    const lines = [];

    for (let hole = 0; hole < 18; hole++) {
      const hasAny = State.data.games.some(g => {
        const ids = [...(g.teamA||[]),...(g.teamB||[])];
        return ids.some(pid => {
          const v = g.gross[pid] && g.gross[pid][hole];
          return v != null;
        });
      });
      if (!hasAny) continue;

      const neutral = State.data.games.map(g => equalizeHole(g, hole));
      const cf = aggTotal(neutral);
      const swing = actual - cf;
      if (swing === 0) continue;

      const contrib = State.data.games.map((g, idx) => {
        const a = Game.computeResult(g).teamTotals.total;
        const c = Game.computeResult(neutral[idx]).teamTotals.total;
        return {gi:idx, delta:a-c, game:g};
      });
      contrib.sort((a,b) => Math.abs(b.delta) - Math.abs(a.delta));
      const top = contrib[0];

      const getGameTotal = (game) => {
        if (game.gameType === 'vegas') {
          return Game.computeVegasResult(game).totalValue;
        } else {
          return Game.computeResult(game).teamTotals.total;
        }
      };

      const perPlayer = [...(top.game.teamA||[]),...(top.game.teamB||[])].map(pid => {
        const g2 = Utils.clone(top.game);
        const s = Game.strokes(g2, pid, hole) || 0;
        g2.gross[pid][hole] = s + 100;
        g2.junkCounts[pid][hole] = 0;
        const cfRes = getGameTotal(g2);
        const actRes = getGameTotal(top.game);
        return {pid, delta:actRes - cfRes};
      }).filter(pc => Math.abs(pc.delta) > 0.001);

      perPlayer.sort((a,b) => Math.abs(b.delta) - Math.abs(a.delta));

      const swingSign = swing > 0 ? 1 : -1;
      const sameDir = perPlayer.filter(pc => Math.sign(pc.delta) === swingSign);
      const rel = sameDir.length ? sameDir : perPlayer;
      if (!rel.length) continue;

      const maxD = Math.max(...rel.map(pc => Math.abs(pc.delta)));
      const tied = rel.filter(pc => Math.abs(Math.abs(pc.delta) - maxD) < 0.001);

      const labelFor = (pid) => {
        const parVal = State.data.course.par[hole];
        const gross = top.game.gross[pid] && top.game.gross[pid][hole];
        if (parVal == null || gross == null) return '';
        const d = gross - parVal;
        if (d <= -3) return 'albatross';
        if (d === -2) return 'eagle';
        if (d === -1) return 'birdie';
        if (d === 1) return 'bogey';
        if (d >= 2) return 'double bogey';
        return gross === parVal ? 'par' : '';
      };

      const pluralize = (s) => {
        if (s === 'par') return 'pars';
        if (s === 'birdie') return 'birdies';
        if (s === 'eagle') return 'eagles';
        if (s === 'bogey') return 'bogeys';
        if (s === 'double bogey') return 'double bogeys';
        if (s === 'albatross') return 'albatrosses';
        return s ? (s + 's') : s;
      };

      const names = tied.map(t => UI.playerName(t.pid));
      const labels = tied.map(t => labelFor(t.pid));

      let whoText;
      const allSame = labels.length && labels.every(l => l && l === labels[0]);
      if (labels.length === 1) {
        whoText = names[0] + (labels[0] ? (' ' + labels[0]) : '');
      } else if (allSame) {
        whoText = names.join(' & ') + (labels[0] ? ("'s " + pluralize(labels[0])) : '');
      } else {
        const parts = names.map((nm, i) => nm + (labels[i] ? (' ' + labels[i]) : ''));
        whoText = parts.join(' & ');
      }

      const toward = swing > 0 ? 'Team A' : 'Team B';
      lines.push({
        hole,
        value:Math.abs(swing),
        swing,
        text:`Hole ${hole+1}: ${whoText} swung ${Utils.fmt(Math.abs(swing))} toward ${toward}`
      });
    }

    lines.sort((a,b) => (b.value - a.value) || (b.hole - a.hole));
    return lines;
  }
};

// === INIT ===
if (!State.load() || !State.data.games.length) {
  State.data.games = [Game.create()];
  State.scheduleSave();
}

State.data.games = State.data.games.map(Game.sanitize);

document.getElementById('resetBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Start a new round? Scores & junk cleared, teams/stakes reset. Custom courses kept.')) return;
  const keepCourse = Utils.clone(State.data.course);
  const keepPresets = Utils.clone(State.presets);
  State.data.games = [Game.create()];
  State.data.course = keepCourse;
  State.presets = keepPresets;
  State.data.roundCompleteShown = false;
  State.scheduleSave();
  State.scheduleRender();
  Err.toast('Round reset');
};

document.getElementById('clearBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Clear all scores & junk? Teams/stakes/course stay the same.')) return;
  State.data.games.forEach(g => {
    State.data.players.forEach(p => {
      g.gross[p.id] = Utils.make18(null);
      g.junkCounts[p.id] = Utils.make18(0);
    });
  });
  State.scheduleSave();
  State.scheduleRender();
  Err.toast('Scores cleared');
};

document.getElementById('factoryBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Factory reset? EVERYTHING erased: scores, teams, strokes, players, ALL presets!')) return;
  localStorage.removeItem(STORAGE_KEY);
  location.reload();
};

// Live sharing buttons
document.getElementById('hostBtn').onclick = () => { UI.closeMenu(); LiveSync.showHostModal(); };
document.getElementById('joinBtn').onclick = () => { UI.closeMenu(); LiveSync.showJoinModal(); };

// Wizard button
document.getElementById('startWizardBtn').onclick = () => { UI.closeMenu(); Wizard.start(); };

// Check URL for join code on load
(function() {
  const params = new URLSearchParams(window.location.search);
  const joinCode = params.get('join');
  if (joinCode) {
    // Remove code from URL to prevent re-joining on refresh
    window.history.replaceState({}, '', window.location.pathname);
    // Delay join to allow app to initialize
    setTimeout(() => LiveSync.joinGame(joinCode), 500);
  }
})();

// iOS detection
(function() {
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && 'ontouchend' in document);
  if (isIOS) document.documentElement.classList.add('ios');
})();

UI.render();
UI.initMenu();

// Intelligent launch detection
(function() {
  const today = new Date().toDateString();
  const lastActive = State.data.lastActiveDate;

  // Check if there's an active game with scores
  const hasActiveGame = () => {
    // Check if any game has at least one score entered
    for (const g of State.data.games) {
      for (const pid of Object.keys(g.gross || {})) {
        const scores = g.gross[pid];
        if (scores && scores.some(s => s !== null)) return true;
      }
    }
    return false;
  };

  // If it's a new day, show wizard for fresh start
  // If same day with active game, go to scores
  if (lastActive !== today) {
    // New day - show wizard
    Wizard.start();
  } else if (hasActiveGame()) {
    // Same day with active game - go to scores tab
    State.data.tab = 'live';
    State.scheduleRender();
    Err.toast('Welcome back');
  } else {
    // Same day but no active game - show wizard
    Wizard.start();
  }
})();

})();
</script>
</body>
</html>

